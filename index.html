<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lerntool E1 / E2a</title>
  <!-- Tailwind √ºber CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: 'class' };</script>
  <!-- React & ReactDOM UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel (damit JSX direkt im Browser funktioniert) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-100">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useContext } = React;

    // ========= Utility =========
    function xmur3(str){
      let h = 1779033703 ^ str.length;
      for(let i=0;i<str.length;i++){
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = h << 13 | h >>> 19;
      }
      return function(){
        h = Math.imul(h ^ h >>> 16, 2246822507);
        h = Math.imul(h ^ h >>> 13, 3266489909);
        return (h ^ h >>> 16) >>> 0;
      };
    }

    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function seededShuffle(array, seedStr){
      const seed = xmur3(seedStr)();
      const rng = mulberry32(seed);
      const a = [...array];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rng()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function cloneValue(value){
      if(Array.isArray(value)) return value.map(cloneValue);
      if(value && typeof value === "object") return JSON.parse(JSON.stringify(value));
      return value;
    }

    function hashPassword(str=""){
      let hash = 0;
      for(let i=0;i<str.length;i++){
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return `h${Math.abs(hash)}`;
    }

    function passwordsMatch(hash, plain){
      return hash === hashPassword(plain);
    }

    function generateId(prefix="id"){
      const cleanPrefix = prefix.replace(/[^a-z0-9]+/gi, "").toLowerCase() || "id";
      return `${cleanPrefix}-${Math.random().toString(36).slice(2,8)}-${Date.now().toString(36)}`;
    }

    const DEFAULT_ADMIN_USER = { id:"admin", username:"Admin", passwordHash:hashPassword("admin"), role:"admin", createdAt:new Date(2023,0,1).toISOString() };

    function normalizeUsers(raw){
      const arr = Array.isArray(raw) ? raw : [];
      const map = new Map();
      for(const item of arr){
        if(!item || typeof item !== "object") continue;
        const id = typeof item.id === "string" ? item.id : generateId("user");
        const username = typeof item.username === "string" && item.username.trim() ? item.username.trim() : "Nutzer";
        const passwordHash = typeof item.passwordHash === "string" ? item.passwordHash : hashPassword("passwort");
        const createdAt = typeof item.createdAt === "string" ? item.createdAt : new Date().toISOString();
        if(id === DEFAULT_ADMIN_USER.id){
          map.set(DEFAULT_ADMIN_USER.id, { ...DEFAULT_ADMIN_USER, username, passwordHash, createdAt });
        } else {
          map.set(id, { id, username, passwordHash, role:"user", createdAt });
        }
      }
      if(!map.has(DEFAULT_ADMIN_USER.id)){
        map.set(DEFAULT_ADMIN_USER.id, { ...DEFAULT_ADMIN_USER });
      }
      return Array.from(map.values());
    }

    function readLocalStorage(key, initialValue){
      try{
        const stored = localStorage.getItem(key);
        if(stored !== null){
          return JSON.parse(stored);
        }
      }catch{}
      const fallback = typeof initialValue === "function" ? initialValue() : initialValue;
      return cloneValue(fallback);
    }

    function useLocalStorage(key, initialValue){
      const initializer = () => readLocalStorage(key, initialValue);
      const [state, setState] = useState(initializer);
      useEffect(()=>{
        setState(readLocalStorage(key, initialValue));
      },[key]);
      useEffect(()=>{
        try{
          localStorage.setItem(key, JSON.stringify(state));
        }catch{}
      },[key,state]);
      return [state, setState];
    }

    const SessionContext = React.createContext(null);
    function useSession(){
      return useContext(SessionContext);
    }

    function useScopedStorage(baseKey, initialValue){
      const session = useSession();
      const userId = session?.activeUser?.id || "anon";
      return useLocalStorage(`user:${userId}:${baseKey}`, initialValue);
    }

    const COLOR = {
      BDG:   { bg:"bg-yellow-50", border:"border-yellow-400", bar:"bg-yellow-400", grad:"from-yellow-400 to-amber-500", text:"text-yellow-700 dark:text-yellow-200" },
      SPG:   { bg:"bg-blue-50",   border:"border-blue-500",   bar:"bg-blue-500",   grad:"from-blue-600 to-indigo-600", text:"text-blue-700 dark:text-blue-200" },
      StPO:  { bg:"bg-red-50",    border:"border-red-500",    bar:"bg-red-500",    grad:"from-rose-600 to-red-600", text:"text-red-700 dark:text-rose-200" },
      StGB:  { bg:"bg-red-50",    border:"border-red-500",    bar:"bg-red-500",    grad:"from-rose-600 to-red-600", text:"text-red-700 dark:text-rose-200" },
      ADMIN: { bg:"bg-green-50",  border:"border-green-600",  bar:"bg-green-600",  grad:"from-emerald-600 to-green-600", text:"text-green-700 dark:text-emerald-200" },
    };

    const GROUPS = [
      { key:"BDG",   title:"Dienstrecht (BDG)",           tags:["BDG"], color:COLOR.BDG },
      { key:"SPG",   title:"Sicherheitspolizei (SPG)",     tags:["SPG"], color:COLOR.SPG },
      { key:"STPO",  title:"Strafprozess/StGB",            tags:["StPO","StGB"], color:COLOR.StPO },
      { key:"ADMIN", title:"Verwaltung & Verkehr",          tags:["AVG","VStG","WaffG","StVO","KFG","FSG"], color:COLOR.ADMIN },
    ];

    const RANKS = [
      { title: "Anw√§rter:in", min: 0 },
      { title: "Inspektor:in", min: 150 },
      { title: "Gruppeninspektor:in", min: 400 },
      { title: "Revierinspektor:in", min: 800 },
      { title: "Abteilungsinspektor:in", min: 1300 },
      { title: "Chefinspektor:in", min: 2000 },
    ];

    const DEFAULT_QUESTIONS = [
      { id: "bdg-43-ma-1", question:"¬ß 43 BDG: Wie hat ein Beamter seine dienstlichen Aufgaben zu erf√ºllen? W√§hlen Sie alle zutreffenden.", choices:["Unter Beachtung der geltenden Rechtsordnung.","Treu, gewissenhaft, engagiert und unparteiisch.","Nur nach st√§ndiger R√ºcksprache mit dem unmittelbaren Vorgesetzten.","So, dass das Vertrauen der Allgemeinheit erhalten bleibt.","Prim√§r an interne Dienstanweisungen, nicht an Gesetze, gebunden."], correct:[0,1,3], explain:"¬ß 43 BDG: Rechtstreue, Gewissenhaftigkeit, Engagement, Unparteilichkeit und Wahrung des Vertrauens der Allgemeinheit.", law_ref:"BDG ¬ß 43", tags:["BDG"], last_checked:"2025-11-11", difficulty:1 },
      { id:"bdg-44-ma-1", question:"¬ß 44 BDG (Weisungen): In welchen F√§llen ist zu remonstrieren/abzulehnen? W√§hlen Sie alle zutreffenden.", choices:["Wenn die Weisung von einem unzust√§ndigen Organ erteilt wurde.","Wenn die Befolgung gegen verwaltungsrechtliche Vorschriften verstie√üe.","Wenn die Befolgung gegen strafrechtliche Vorschriften verstie√üe.","Wenn der Inhalt unklar ist und trotz Nachfrage unklar bleibt.","Wenn die Weisung m√ºndlich erteilt wurde."], correct:[0,1,2,3], explain:"Unzust√§ndigkeit oder Rechtswidrigkeit ‚Üí Remonstrationspflicht; M√ºndlichkeit allein macht eine Weisung nicht unbeachtlich.", law_ref:"BDG ¬ß 44", tags:["BDG"], last_checked:"2025-11-11", difficulty:2 },
      { id:"bdg-43a-ma-1", question:"¬ß 43a BDG (achtungsvoller Umgang): Welche Aussagen treffen zu? W√§hlen Sie alle zutreffenden.", choices:["Beamte haben menschenw√ºrdeverletzendes Verhalten zu unterlassen.","Vorgesetzte und Mitarbeiter begegnen einander mit Achtung.","Spontane Entgleisungen sind disziplin√§r immer irrelevant.","Vorgesetzte haben f√ºr achtungsvollen Umgang Sorge zu tragen.","¬ß 43a betrifft nur den Umgang mit Parteien."], correct:[0,1,3], explain:"¬ß 43a BDG verlangt w√ºrdevollen, diskriminierungsfreien Umgang; spontane Entgleisungen k√∂nnen relevant sein.", law_ref:"BDG ¬ß 43a", tags:["BDG"], last_checked:"2025-11-11", difficulty:1 },
      { id:"bdg-39-ma-1", question:"¬ß 39 BDG (Dienstzuteilung): Unter welchen Bedingungen ist eine Zuteilung ohne schriftliche Zustimmung √ºber 90 Tage zul√§ssig? W√§hlen Sie alle zutreffenden.", choices:["Wenn der Dienstbetrieb auf andere Weise nicht aufrechterhalten werden kann.","Wenn sie zum Zwecke einer Ausbildung erfolgt.","Wenn wichtige private Gr√ºnde vorliegen.","Wenn der Kommandant der entsendenden Dienststelle zustimmt.","Wenn der Kommandant der Zuteilungsdienststelle zustimmt."], correct:[0,1], explain:">90 Tage ohne Zustimmung: nur zur Aufrechterhaltung des Dienstbetriebs oder zu Ausbildungszwecken.", law_ref:"BDG ¬ß 39", tags:["BDG"], last_checked:"2025-11-11", difficulty:2 },
    ];

    const MIN_TIER = 1, MAX_TIER = 5;
    const DEFAULT_FILTER = { tags: [], difficulty: 0 };
    const DEFAULT_METRICS = { totalAttempts: 0, totalCorrect: 0, attemptedIds: {}, correctIds: {} };
    const tierWeight = (tier) => ({ 1:5, 2:3, 3:2, 4:1.2, 5:1 }[tier] || 1);

    function rankFor(score){
      const r = [...RANKS].reverse().find(r=>score>=r.min);
      return r ? r.title : RANKS[0].title;
    }

    function Chip({ children, className="" }){
      return <span className={`px-2 py-1 text-xs rounded-full border mr-2 mb-2 inline-block ${className}`}>{children}</span>;
    }

    function StatCard({ title, value, sub }){
      return (
        <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow">
          <div className="text-xs text-gray-500 dark:text-gray-400">{title}</div>
          <div className="text-2xl font-semibold mt-1">{value}</div>
          {sub ? <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">{sub}</div> : null}
        </div>
      );
    }

    function Dashboard({ stats, rank, score, reviewCount }){
      const cards = GROUPS.map(g=>({ ...stats[g.key], key:g.key }));
      return (
        <div className="space-y-6">
          <div className="grid md:grid-cols-4 sm:grid-cols-2 grid-cols-1 gap-4">
            {cards.map(c=>{
              const attemptedPct = c.total? Math.round((c.attempted/c.total)*100):0;
              const correctPct   = c.attempted? Math.round((c.correct/c.attempted)*100):0;
              return (
                <div key={c.key} className={`rounded-2xl p-4 border shadow ${c.color.bg} ${c.color.border} dark:bg-gray-800 dark:border-gray-700`}>
                  <div className={`text-sm font-semibold ${c.color.text}`}>{GROUPS.find(g=>g.key===c.key).title}</div>
                  <div className="mt-2 text-xs text-gray-600 dark:text-gray-300">Fragen: {c.total} ¬∑ Bearbeitet: {c.attempted} ¬∑ Richtig: {c.correct}</div>
                  <div className="mt-3">
                    <div className="text-xs mb-1">Abdeckung</div>
                    <div className="w-full h-2 bg-white/70 rounded-full overflow-hidden border">
                      <div className={`h-2 ${c.color.bar}`} style={{ width: `${attemptedPct}%`}} />
                    </div>
                  </div>
                  <div className="mt-2">
                    <div className="text-xs mb-1">Trefferquote</div>
                    <div className="w-full h-2 bg-white/70 rounded-full overflow-hidden border">
                      <div className={`h-2 ${c.color.bar}`} style={{ width: `${correctPct}%`}} />
                    </div>
                  </div>
                </div>
              )
            })}
          </div>
          <div className="grid md:grid-cols-3 gap-4">
            <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow"><div className="text-xs text-gray-500 dark:text-gray-400">Aktueller Rang</div><div className="text-2xl font-bold mt-1">{rank}</div></div>
            <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow"><div className="text-xs text-gray-500 dark:text-gray-400">Gesamtpunkte</div><div className="text-2xl font-bold mt-1">{score}</div></div>
            <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow"><div className="text-xs text-gray-500 dark:text-gray-400">Wiederholungs-Queue</div><div className="text-2xl font-bold mt-1">{reviewCount}</div></div>
          </div>
        </div>
      );
    }

    function QuestionCard({ q, idx, submitted, onSubmit, onNext, getTierValue }){
      const [selectedDisplay, setSelectedDisplay] = useState([]);
      const displayOrder = useMemo(()=> seededShuffle([0,1,2,3,4], `${q.id}#${idx}`), [q.id, idx]);
      useEffect(()=>{ setSelectedDisplay([]); }, [q.id, idx]);
      const toggle = (dispIdx) => setSelectedDisplay(prev => prev.includes(dispIdx)? prev.filter(x=>x!==dispIdx):[...prev, dispIdx]);
      const correctSet = new Set(q.correct);
      const group = GROUPS.find(g=>q.tags.some(t=>g.tags.includes(t))) || GROUPS[GROUPS.length-1];
      const tierValue = getTierValue(q.id);
      return (
        <div className="bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-0 overflow-hidden">
          <div className={`h-2 w-full bg-gradient-to-r ${group.color.grad}`} />
          <div className="p-6">
            <div className="mb-3 text-xs text-gray-500 dark:text-gray-400 flex flex-wrap items-center gap-2">
              {q.tags.map(t => (<Chip key={t} className={`${group.color.bg} ${group.color.border} ${group.color.text}`}>{t}</Chip>))}
              <Chip>Schwierigkeit {q.difficulty}</Chip>
              <Chip>Stand {q.last_checked}</Chip>
              <Chip>Tier {tierValue}</Chip>
            </div>
            <h2 className="text-lg font-semibold mb-4">{q.question}</h2>
            <div className="grid gap-2">
              {displayOrder.map((origIdx, dispIdx) => {
                const isChosen = selectedDisplay.includes(dispIdx);
                const isCorrect = correctSet.has(origIdx);
                const show = submitted;
                let classes = "text-left px-4 py-3 rounded-xl border transition flex items-start gap-3 dark:border-gray-700";
                if (show) {
                  if (isCorrect) {
                    classes += " border-green-600 bg-green-50 dark:border-green-400 dark:bg-green-900/40";
                  } else if (isChosen) {
                    classes += " border-red-600 bg-red-50 dark:border-red-400 dark:bg-red-900/40";
                  } else {
                    classes += " bg-white dark:bg-gray-800";
                  }
                } else {
                  classes += " bg-white hover:bg-gray-50 dark:bg-gray-800 dark:hover:bg-gray-700";
                }
                return (
                  <label key={dispIdx} className={classes}>
                    <input type="checkbox" className="mt-1" disabled={submitted} checked={isChosen} onChange={()=>toggle(dispIdx)} />
                    <span><span className="font-medium mr-2">{String.fromCharCode(65+dispIdx)}.</span>{q.choices[origIdx]}</span>
                  </label>
                );
              })}
            </div>
            {!submitted ? (
              <div className="mt-4 flex gap-2">
                <button className="px-3 py-2 rounded-lg border dark:border-gray-600" onClick={() => onSubmit(selectedDisplay)}>Antwort abgeben</button>
                <button className="px-3 py-2 rounded-lg border dark:border-gray-600" onClick={onNext}>√úberspringen</button>
              </div>
            ) : (
              <div className="mt-4 p-4 border rounded-xl bg-gray-50 dark:bg-gray-900 dark:border-gray-700">
                <div className="text-sm">
                  <div className="font-semibold mb-1">Aufl√∂sung & Erl√§uterung</div>
                  <p className="mb-2">{q.explain}</p>
                  <div className="text-xs text-gray-600 dark:text-gray-300">Rechtsgrundlage: {q.law_ref}</div>
                </div>
                <div className="mt-3 flex gap-2">
                  <button className="px-3 py-2 rounded-lg border" onClick={onNext}>Weiter</button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function useQuestions(){
      const [questions, setQuestions] = useLocalStorage('questions', () => DEFAULT_QUESTIONS);
      useEffect(()=>{
        if(!Array.isArray(questions) || !questions.length){
          setQuestions(() => cloneValue(DEFAULT_QUESTIONS));
        }
      },[questions, setQuestions]);
      return { questions: Array.isArray(questions)? questions : DEFAULT_QUESTIONS, setQuestions };
    }

    function AuthScreen({ onLogin, onRegister, message, error }){
      const [mode, setMode] = useState('login');
      const [username, setUsername] = useState('');
      const [password, setPassword] = useState('');
      const [confirm, setConfirm] = useState('');
      const [localError, setLocalError] = useState('');

      useEffect(()=>{ setLocalError(''); }, [mode, username, password, confirm]);

      const submit = (e) => {
        e.preventDefault();
        const trimmed = username.trim();
        if(!trimmed){ setLocalError('Bitte Benutzername eingeben.'); return; }
        if(!password){ setLocalError('Bitte Passwort eingeben.'); return; }
        if(mode==='register'){
          if(password.length < 4){ setLocalError('Passwort muss mindestens 4 Zeichen enthalten.'); return; }
          if(password !== confirm){ setLocalError('Passw√∂rter stimmen nicht √ºberein.'); return; }
          onRegister(trimmed, password);
        } else {
          onLogin(trimmed, password);
        }
      };

      return (
        <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-600 to-indigo-700 p-6">
          <div className="max-w-md w-full bg-white/95 backdrop-blur rounded-3xl shadow-xl p-8">
            <h1 className="text-2xl font-bold text-center text-gray-800 mb-6">Lerntool E1 / E2a</h1>
            <div className="text-sm text-gray-600 mb-4">
              <p>Standard-Admin: <strong>Benutzername</strong> <code>Admin</code>, <strong>Passwort</strong> <code>admin</code>.</p>
            </div>
            <div className="flex gap-2 mb-6">
              <button onClick={()=>setMode('login')} className={`flex-1 py-2 rounded-full border ${mode==='login'? 'bg-blue-600 text-white border-blue-600':'border-gray-300 text-gray-600'}`}>Anmelden</button>
              <button onClick={()=>setMode('register')} className={`flex-1 py-2 rounded-full border ${mode==='register'? 'bg-indigo-600 text-white border-indigo-600':'border-gray-300 text-gray-600'}`}>Registrieren</button>
            </div>
            <form onSubmit={submit} className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Benutzername</label>
                <input value={username} onChange={e=>setUsername(e.target.value)} className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring focus:border-blue-500" placeholder="z.B. Max" />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Passwort</label>
                <input value={password} onChange={e=>setPassword(e.target.value)} type="password" className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring focus:border-blue-500" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
              </div>
              {mode==='register' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Passwort best√§tigen</label>
                  <input value={confirm} onChange={e=>setConfirm(e.target.value)} type="password" className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring focus:border-blue-500" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
                </div>
              )}
              {(localError || error) && <div className="text-sm text-red-600">{localError || error}</div>}
              {message && !localError && !error && <div className="text-sm text-green-600">{message}</div>}
              <button type="submit" className="w-full py-2 rounded-lg bg-blue-600 text-white font-semibold">{mode==='login'? 'Anmelden':'Konto anlegen'}</button>
            </form>
          </div>
        </div>
      );
    }

    function PasswordChangeForm({ onSubmit }){
      const [current, setCurrent] = useState('');
      const [next, setNext] = useState('');
      const [confirm, setConfirm] = useState('');
      const [status, setStatus] = useState(null);
      const [error, setError] = useState(null);

      const handleSubmit = (e) => {
        e.preventDefault();
        setError(null); setStatus(null);
        if(!current || !next){ setError('Bitte alle Felder ausf√ºllen.'); return; }
        if(next.length < 4){ setError('Neues Passwort muss mindestens 4 Zeichen haben.'); return; }
        if(next !== confirm){ setError('Passw√∂rter stimmen nicht √ºberein.'); return; }
        const result = onSubmit(current, next);
        if(result.ok){
          setStatus('Passwort erfolgreich aktualisiert.');
          setCurrent(''); setNext(''); setConfirm('');
        } else {
          setError(result.error || '√Ñnderung fehlgeschlagen.');
        }
      };

      return (
        <form onSubmit={handleSubmit} className="space-y-3">
          <div>
            <label className="block text-xs font-medium mb-1">Aktuelles Passwort</label>
            <input type="password" value={current} onChange={e=>setCurrent(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
          </div>
          <div>
            <label className="block text-xs font-medium mb-1">Neues Passwort</label>
            <input type="password" value={next} onChange={e=>setNext(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
          </div>
          <div>
            <label className="block text-xs font-medium mb-1">Neues Passwort best√§tigen</label>
            <input type="password" value={confirm} onChange={e=>setConfirm(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
          </div>
          {error && <div className="text-xs text-red-500">{error}</div>}
          {status && <div className="text-xs text-green-500">{status}</div>}
          <button type="submit" className="px-3 py-2 rounded-lg border dark:border-gray-600">Passwort √§ndern</button>
        </form>
      );
    }

    function QuestionForm({ value, onChange, onSubmit, submitLabel }){
      const updateField = (field, val) => {
        onChange(prev => ({ ...prev, [field]: val }));
      };

      const updateChoice = (index, val) => {
        onChange(prev => {
          const choices = [...prev.choices];
          choices[index] = val;
          return { ...prev, choices };
        });
      };

      return (
        <form onSubmit={onSubmit} className="space-y-3">
          <div>
            <label className="block text-xs font-medium mb-1">Fragetext</label>
            <textarea value={value.question} onChange={e=>updateField('question', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" rows="3" />
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {value.choices.map((choice, idx) => (
              <div key={idx}>
                <label className="block text-xs font-medium mb-1">Antwort {String.fromCharCode(65+idx)}</label>
                <textarea value={choice} onChange={e=>updateChoice(idx, e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" rows="2" />
              </div>
            ))}
          </div>
          <div className="grid md:grid-cols-3 gap-3">
            <div>
              <label className="block text-xs font-medium mb-1">Korrekte Indizes (z.B. 0,2,4)</label>
              <input value={value.correctText} onChange={e=>updateField('correctText', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
            </div>
            <div>
              <label className="block text-xs font-medium mb-1">Tags (Komma-getrennt)</label>
              <input value={value.tagsText} onChange={e=>updateField('tagsText', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
            </div>
            <div>
              <label className="block text-xs font-medium mb-1">Schwierigkeit (1-5)</label>
              <input value={value.difficulty} onChange={e=>updateField('difficulty', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
            </div>
          </div>
          <div className="grid md:grid-cols-2 gap-3">
            <div>
              <label className="block text-xs font-medium mb-1">Rechtsgrundlage</label>
              <input value={value.law_ref} onChange={e=>updateField('law_ref', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
            </div>
            <div>
              <label className="block text-xs font-medium mb-1">Zuletzt gepr√ºft (YYYY-MM-DD)</label>
              <input value={value.last_checked} onChange={e=>updateField('last_checked', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" />
            </div>
          </div>
          <div>
            <label className="block text-xs font-medium mb-1">Erkl√§rung</label>
            <textarea value={value.explain} onChange={e=>updateField('explain', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 bg-white dark:bg-gray-900" rows="3" />
          </div>
          <button type="submit" className="px-4 py-2 rounded-lg border dark:border-gray-600">{submitLabel}</button>
        </form>
      );
    }

    function AdminPanel({ questions, setQuestions }){
      const [editingId, setEditingId] = useState(null);
      const [editForm, setEditForm] = useState(null);
      const [newForm, setNewForm] = useState({
        question: "",
        choices: Array(5).fill(""),
        correctText: "",
        explain: "",
        law_ref: "",
        tagsText: "",
        last_checked: new Date().toISOString().slice(0,10),
        difficulty: "1",
      });
      const [feedback, setFeedback] = useState(null);

      const startEdit = (q) => {
        setEditingId(q.id);
        setEditForm({
          id: q.id,
          question: q.question,
          choices: [...q.choices],
          correctText: (Array.isArray(q.correct)? q.correct : []).join(','),
          explain: q.explain || "",
          law_ref: q.law_ref || "",
          tagsText: (Array.isArray(q.tags)? q.tags : []).join(', '),
          last_checked: q.last_checked || new Date().toISOString().slice(0,10),
          difficulty: String(q.difficulty ?? 1),
        });
        setFeedback(null);
      };

      const parseCorrect = (str) => {
        return str.split(',').map(s=>s.trim()).filter(Boolean).map(Number).filter(n=>Number.isInteger(n) && n>=0 && n<5);
      };

      const parseTags = (str) => {
        return str.split(',').map(s=>s.trim()).filter(Boolean);
      };

      const validateQuestion = (payload) => {
        if(!payload.question.trim()) return 'Fragetext darf nicht leer sein.';
        if(!payload.choices.every(c=>c && c.trim())) return 'Alle Antwortm√∂glichkeiten m√ºssen ausgef√ºllt sein.';
        if(!payload.correct.length) return 'Mindestens ein korrekter Index erforderlich.';
        if(payload.correct.some(idx => idx<0 || idx>=payload.choices.length)) return 'Korrekte Indizes au√üerhalb des g√ºltigen Bereichs.';
        if(!payload.tags.length) return 'Mindestens ein Tag erforderlich.';
        const diff = Number(payload.difficulty);
        if(!Number.isFinite(diff) || diff<1 || diff>5) return 'Schwierigkeit muss zwischen 1 und 5 liegen.';
        if(!/\d{4}-\d{2}-\d{2}/.test(payload.last_checked)) return 'Datum muss im Format YYYY-MM-DD vorliegen.';
        return null;
      };

      const submitEdit = (e) => {
        e.preventDefault();
        if(!editForm) return;
        const tags = parseTags(editForm.tagsText);
        const payload = {
          id: editForm.id,
          question: editForm.question.trim(),
          choices: editForm.choices.map(c=>c.trim()),
          correct: parseCorrect(editForm.correctText),
          explain: editForm.explain.trim(),
          law_ref: editForm.law_ref.trim(),
          tags,
          last_checked: editForm.last_checked.trim(),
          difficulty: Number(editForm.difficulty),
        };
        const errorMsg = validateQuestion(payload);
        if(errorMsg){ setFeedback({ type:'error', text:errorMsg }); return; }
        setQuestions(prev => {
          const list = Array.isArray(prev)? [...prev] : [];
          const idx = list.findIndex(q=>q.id===payload.id);
          if(idx>=0){ list[idx] = { ...list[idx], ...payload }; }
          return list;
        });
        setFeedback({ type:'success', text:'Frage aktualisiert.' });
        setEditingId(null);
        setEditForm(null);
      };

      const submitNew = (e) => {
        e.preventDefault();
        const tags = parseTags(newForm.tagsText);
        const payload = {
          id: generateId((tags[0] || 'frage').slice(0,8) || 'frage'),
          question: newForm.question.trim(),
          choices: newForm.choices.map(c=>c.trim()),
          correct: parseCorrect(newForm.correctText),
          explain: newForm.explain.trim(),
          law_ref: newForm.law_ref.trim(),
          tags,
          last_checked: newForm.last_checked.trim(),
          difficulty: Number(newForm.difficulty),
        };
        const errorMsg = validateQuestion(payload);
        if(errorMsg){ setFeedback({ type:'error', text:errorMsg }); return; }
        setQuestions(prev => {
          const list = Array.isArray(prev)? [...prev] : [];
          list.push(payload);
          return list;
        });
        setNewForm({
          question: "",
          choices: Array(5).fill(""),
          correctText: "",
          explain: "",
          law_ref: "",
          tagsText: "",
          last_checked: new Date().toISOString().slice(0,10),
          difficulty: "1",
        });
        setFeedback({ type:'success', text:'Neue Frage hinzugef√ºgt.' });
      };

      return (
        <div className="mt-10 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6">
          <h3 className="text-lg font-semibold mb-4">Admin ¬∑ Fragenverwaltung</h3>
          {feedback && (
            <div className={`mb-4 text-sm ${feedback.type==='error' ? 'text-red-500' : 'text-green-500'}`}>{feedback.text}</div>
          )}
          <div className="space-y-6">
            <div>
              <h4 className="font-semibold mb-2">Fragen bearbeiten</h4>
              <div className="max-h-64 overflow-y-auto border border-dashed border-gray-300 dark:border-gray-700 rounded-xl">
                <table className="w-full text-sm">
                  <thead className="bg-gray-100 dark:bg-gray-900">
                    <tr className="text-left">
                      <th className="px-3 py-2">ID</th>
                      <th className="px-3 py-2">Frage</th>
                      <th className="px-3 py-2">Aktion</th>
                    </tr>
                  </thead>
                  <tbody>
                    {questions.map(q => (
                      <tr key={q.id} className="border-t border-gray-200 dark:border-gray-700">
                        <td className="px-3 py-2 whitespace-nowrap text-xs">{q.id}</td>
                        <td className="px-3 py-2">{q.question.slice(0,80)}{q.question.length>80?'‚Ä¶':''}</td>
                        <td className="px-3 py-2 text-right">
                          <button onClick={()=>startEdit(q)} className="px-3 py-1 rounded-full border text-xs">Bearbeiten</button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              {editForm && (
                <div className="mt-4 p-4 border rounded-2xl dark:border-gray-700">
                  <div className="flex justify-between items-center mb-3">
                    <h5 className="font-semibold">Frage {editingId} bearbeiten</h5>
                    <button onClick={()=>{setEditingId(null); setEditForm(null);}} className="text-xs text-gray-500">Schlie√üen</button>
                  </div>
                  <QuestionForm value={editForm} onChange={setEditForm} onSubmit={submitEdit} submitLabel="√Ñnderungen speichern" />
                </div>
              )}
            </div>
            <div className="p-4 border rounded-2xl dark:border-gray-700">
              <h4 className="font-semibold mb-3">Neue Frage hinzuf√ºgen</h4>
              <QuestionForm value={newForm} onChange={setNewForm} onSubmit={submitNew} submitLabel="Frage hinzuf√ºgen" />
            </div>
          </div>
        </div>
      );
    }

    function MainApp({ onLogout, onChangePassword }){
      const session = useSession();
      const activeUser = session?.activeUser;
      const { questions: QUESTIONS, setQuestions } = useQuestions();
      const [view, setView] = useScopedStorage('view','dashboard');
      const [mode, setMode] = useScopedStorage('mode','training');
      const [filter, setFilter] = useScopedStorage('filter', DEFAULT_FILTER);
      const [review, setReview] = useScopedStorage('review', []);
      const [metrics, setMetrics] = useScopedStorage('metrics', DEFAULT_METRICS);
      const [score, setScore] = useScopedStorage('score', 0);
      const [streak, setStreak] = useScopedStorage('streak', 0);
      const [idx, setIdx] = useScopedStorage('idx', 0);
      const [showExplain, setShowExplain] = useState(false);
      const [theme, setTheme] = useScopedStorage('theme','light');
      const [tierMap, setTierMap] = useScopedStorage('tiers', {});

      useEffect(()=>{
        if(theme === 'dark'){ document.documentElement.classList.add('dark'); }
        else { document.documentElement.classList.remove('dark'); }
      },[theme]);

      const filterSafe = useMemo(()=>{
        const base = (filter && typeof filter === 'object') ? filter : DEFAULT_FILTER;
        const tags = Array.isArray(base.tags) ? base.tags.filter(Boolean) : [];
        const difficulty = Number(base.difficulty) || 0;
        return { tags, difficulty };
      },[filter]);

      const metricsSafe = useMemo(()=>{
        const base = (metrics && typeof metrics === 'object') ? metrics : DEFAULT_METRICS;
        return {
          totalAttempts: Number(base.totalAttempts) || 0,
          totalCorrect: Number(base.totalCorrect) || 0,
          attemptedIds: (base.attemptedIds && typeof base.attemptedIds === 'object') ? base.attemptedIds : {},
          correctIds: (base.correctIds && typeof base.correctIds === 'object') ? base.correctIds : {},
        };
      },[metrics]);

      const tierSafe = useMemo(()=> (tierMap && typeof tierMap === 'object') ? tierMap : {}, [tierMap]);

      const getTierValue = useCallback((id) => {
        const raw = tierSafe[id];
        const val = typeof raw === 'number' ? raw : 2;
        return Math.max(MIN_TIER, Math.min(MAX_TIER, val));
      },[tierSafe]);

      const setTierValue = useCallback((id, updater) => {
        setTierMap(prev => {
          const base = (prev && typeof prev === 'object') ? { ...prev } : {};
          const current = typeof base[id] === 'number' ? base[id] : 2;
          const nextVal = typeof updater === 'function' ? updater(current) : updater;
          base[id] = Math.max(MIN_TIER, Math.min(MAX_TIER, nextVal));
          return base;
        });
      },[setTierMap]);

      const pool = useMemo(()=>{
        let p = QUESTIONS;
        if(filterSafe.tags.length){
          p = p.filter(q => q.tags.some(t => filterSafe.tags.includes(t)));
        }
        if(filterSafe.difficulty){
          p = p.filter(q => q.difficulty === filterSafe.difficulty);
        }
        if(mode === 'mission'){
          const firstTag = filterSafe.tags[0] || 'BDG';
          p = p.filter(q => q.tags.includes(firstTag));
        }
        const scored = p.map(q => {
          const tier = getTierValue(q.id);
          const weight = tierWeight(tier);
          return { q, score: Math.random() ** (1/weight) };
        }).sort((a,b)=>b.score - a.score);
        return scored.map(entry => entry.q);
      },[QUESTIONS, filterSafe, mode, getTierValue]);

      const current = pool.length ? pool[idx % pool.length] : null;

      function submitAnswer(selectedDisplayIdx){
        if(!current) return;
        const displayOrder = seededShuffle([0,1,2,3,4], `${current.id}#${idx}`);
        const toOriginal = (i) => displayOrder[i];
        const selectedOriginalIdx = selectedDisplayIdx.map(toOriginal);
        const correctSet = new Set(current.correct);
        const selectedSet = new Set(selectedOriginalIdx);
        const allOptions = current.choices.map((_,i)=>i);
        const isExact = allOptions.every(i=>correctSet.has(i) === selectedSet.has(i));
        setShowExplain(true);
        if(isExact){
          setScore(s => (typeof s === 'number' ? s : 0) + 10);
          setStreak(s => (typeof s === 'number' ? s : 0) + 1);
          setReview(r => (Array.isArray(r) ? r.filter(id=>id!==current.id) : []));
          setTierValue(current.id, val => val + 1);
        } else {
          setStreak(0);
          setReview(r => {
            const list = Array.isArray(r) ? [...r] : [];
            if(!list.includes(current.id)) list.push(current.id);
            return list;
          });
          setTierValue(current.id, val => val - 1);
        }
        setMetrics(m => {
          const base = (m && typeof m === 'object') ? m : DEFAULT_METRICS;
          const attemptedIds = { ...(base.attemptedIds || {}) };
          const correctIds = { ...(base.correctIds || {}) };
          attemptedIds[current.id] = (attemptedIds[current.id] || 0) + 1;
          if(isExact){
            correctIds[current.id] = (correctIds[current.id] || 0) + 1;
          }
          return {
            totalAttempts: (base.totalAttempts || 0) + 1,
            totalCorrect: (base.totalCorrect || 0) + (isExact ? 1 : 0),
            attemptedIds,
            correctIds,
          };
        });
      }

      function next(){
        setIdx(i => (typeof i === 'number' ? i : 0) + 1);
        setShowExplain(false);
      }

      const stats = useMemo(()=>{
        const result = {};
        for(const g of GROUPS){
          result[g.key] = { total:0, attempted:0, correct:0, color:g.color, title:g.title };
        }
        for(const q of QUESTIONS){
          const group = GROUPS.find(g=>q.tags.some(t=>g.tags.includes(t))) || GROUPS[GROUPS.length-1];
          const key = group.key;
          result[key].total++;
          const attempts = metricsSafe.attemptedIds?.[q.id] || 0;
          const correct = metricsSafe.correctIds?.[q.id] || 0;
          result[key].attempted += attempts;
          result[key].correct += correct;
        }
        return result;
      },[QUESTIONS, metricsSafe]);

      const toggleTag = useCallback((tag) => {
        setFilter(prev => {
          const base = (prev && typeof prev === 'object') ? prev : DEFAULT_FILTER;
          const tags = Array.isArray(base.tags) ? base.tags : [];
          const exists = tags.includes(tag);
          const nextTags = exists ? tags.filter(t=>t!==tag) : [...tags, tag];
          return { ...base, tags: nextTags };
        });
      },[setFilter]);

      const resetProgress = () => {
        setTierMap({});
        setReview([]);
        setMetrics(DEFAULT_METRICS);
        setScore(0);
        setStreak(0);
        setIdx(0);
        setFilter(DEFAULT_FILTER);
        setMode('training');
        setView('dashboard');
        setShowExplain(false);
        alert('Fortschritt zur√ºckgesetzt.');
      };

      const rank = rankFor(typeof score === 'number' ? score : 0);
      const reviewCount = Array.isArray(review) ? review.length : 0;

      return (
        <div className="max-w-5xl mx-auto p-6">
          <header className="mb-6">
            <div className="rounded-2xl p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow flex flex-wrap items-center gap-4 justify-between">
              <div>
                <h1 className="text-2xl font-bold">Lerntool E1 / E2a</h1>
                <p className="text-sm opacity-90">Pr√ºfungsrealistisches MC-Training ¬∑ 5 Optionen ¬∑ Mehrfachauswahl ¬∑ Antwortmischung ¬∑ Spaced Repetition</p>
              </div>
              <div className="flex flex-col items-end gap-1 text-sm">
                <span className="font-semibold">{activeUser?.username}</span>
                <div className="flex gap-2 flex-wrap justify-end">
                  <button onClick={()=>setView('dashboard')} className={`px-3 py-1 rounded-full border ${view==='dashboard'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Dashboard</button>
                  <button onClick={()=>setView('train')} className={`px-3 py-1 rounded-full border ${view==='train'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Training</button>
                  <button onClick={()=>setTheme(theme==='dark'?'light':'dark')} className="px-3 py-1 rounded-full border bg-transparent border-white text-white hover:bg-white/10">
                    {theme==='dark' ? '‚òÄÔ∏è¬†Light' : 'üåô¬†Dark'}
                  </button>
                  <button onClick={onLogout} className="px-3 py-1 rounded-full border bg-transparent border-white text-white hover:bg-white/10">Abmelden</button>
                </div>
              </div>
            </div>
          </header>

          <div className="mb-6 grid md:grid-cols-3 gap-4">
            <div className="p-4 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow">
              <div className="text-xs text-gray-500 dark:text-gray-400 mb-1">Profil</div>
              <div className="text-sm font-semibold mb-2">{activeUser?.username}</div>
              <PasswordChangeForm onSubmit={onChangePassword} />
            </div>
            <div className="p-4 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow">
              <div className="text-xs text-gray-500 dark:text-gray-400 mb-1">Modus</div>
              <div className="mt-2 flex flex-wrap gap-2">
                {['training','exam','mission'].map(val => (
                  <button key={val} onClick={()=>setMode(val)} className={`px-3 py-1 rounded-full border dark:border-gray-600 ${mode===val?'bg-blue-600 text-white':'bg-white dark:bg-gray-700 dark:text-gray-100'}`}>{val}</button>
                ))}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400 mt-3">Fortschritt zur√ºcksetzen</div>
              <button className="mt-2 px-3 py-1 rounded-lg border dark:border-gray-600" onClick={resetProgress}>Zur√ºcksetzen</button>
            </div>
            <div className="p-4 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow">
              <div className="text-xs text-gray-500 dark:text-gray-400 mb-1">Filter</div>
              <div className="mt-2 flex flex-wrap gap-2">
                {GROUPS.flatMap(g=>g.tags).filter((v,i,a)=>a.indexOf(v)===i).map(tag => {
                  const active = filterSafe.tags.includes(tag);
                  return (
                    <button key={tag} onClick={()=>toggleTag(tag)} className={`px-3 py-1 rounded-full border dark:border-gray-600 ${active ? 'bg-blue-100 border-blue-400 dark:bg-blue-900/40' : 'bg-white dark:bg-gray-700 dark:text-gray-100'}`}>{tag}</button>
                  );
                })}
              </div>
            </div>
          </div>

          {view==='dashboard' && (<Dashboard stats={stats} rank={rank} score={typeof score === 'number' ? score : 0} reviewCount={reviewCount} />)}

          {view==='train' && (
            <>
              <div className="mb-4 grid lg:grid-cols-4 sm:grid-cols-2 grid-cols-1 gap-4">
                <StatCard title="Trefferquote" value={`${metricsSafe.totalAttempts ? Math.round((metricsSafe.totalCorrect/metricsSafe.totalAttempts)*100) : 0}%`} sub={`Richtig ${metricsSafe.totalCorrect} ¬∑ Falsch ${Math.max(0, metricsSafe.totalAttempts - metricsSafe.totalCorrect)}`} />
                <StatCard title="Beantwortet gesamt" value={metricsSafe.totalAttempts} sub={`${Object.keys(metricsSafe.attemptedIds || {}).length} unterschiedliche Fragen`} />
                <StatCard title="Streak" value={`${streak} üî•`} sub="in Folge richtig" />
                <StatCard title="Rang" value={rank} sub={`${score} XP`} />
              </div>

              {current ? (
                <QuestionCard q={current} idx={idx} submitted={showExplain} onSubmit={submitAnswer} onNext={next} getTierValue={getTierValue} />
              ) : (
                <div className="bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6">Keine Fragen im aktuellen Filter.</div>
              )}

              <div className="mt-8 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6">
                <h3 className="font-semibold mb-2">Fragen importieren/exportieren (JSON)</h3>
                <p className="text-sm text-gray-600 dark:text-gray-300 mb-3">Format: [{"id","question","choices":[5],"correct":[0,2,4],"explain":"...","law_ref":"...","tags":[...],"last_checked":"YYYY-MM-DD","difficulty":1}]</p>
                <div className="flex gap-2 flex-wrap">
                  <button className="px-3 py-2 rounded-lg border dark:border-gray-600" onClick={() => {
                    const blob = new Blob([JSON.stringify(QUESTIONS, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'fragenbank.json'; a.click(); URL.revokeObjectURL(url);
                  }}>Export</button>

                  <label className="px-3 py-2 rounded-lg border cursor-pointer dark:border-gray-600">Import
                    <input type="file" accept="application/json" className="hidden" onChange={async (e)=>{
                      const file = e.target.files?.[0]; if(!file) return;
                      try{
                        const text = await file.text();
                        const data = JSON.parse(text);
                        const ok = Array.isArray(data) && data.every(q => q && typeof q.id==="string" && typeof q.question==="string" && Array.isArray(q.choices) && q.choices.length===5 && Array.isArray(q.correct) && Array.isArray(q.tags));
                        if(!ok){ alert('Ung√ºltiges Format.'); return; }
                        setQuestions(data);
                        alert(`Import erfolgreich: ${data.length} Fragen √ºbernommen.`);
                      }catch{ alert('Ung√ºltiges JSON.'); }
                    }}/>
                  </label>
                </div>
              </div>

              {session?.activeUser?.role === 'admin' && (
                <AdminPanel questions={QUESTIONS} setQuestions={setQuestions} />
              )}
            </>
          )}
        </div>
      );
    }

    function Root(){
      const [userStore, setUserStore] = useLocalStorage('users', () => [DEFAULT_ADMIN_USER]);
      const users = useMemo(() => normalizeUsers(userStore), [userStore]);
      const setUsers = useCallback((updater) => {
        setUserStore(prev => {
          const base = normalizeUsers(prev);
          const next = typeof updater === 'function' ? updater(base) : updater;
          return normalizeUsers(next);
        });
      },[setUserStore]);
      const [sessionState, setSessionState] = useLocalStorage('session', () => ({ activeUserId: null }));
      const activeUser = useMemo(()=> users.find(u => u.id === sessionState?.activeUserId) || null, [users, sessionState]);
      useEffect(()=>{
        if(!activeUser){
          setSessionState(prev => ({ ...(prev || {}), activeUserId: null }));
        }
      },[activeUser, setSessionState]);
      const [authError, setAuthError] = useState('');
      const [authMessage, setAuthMessage] = useState('');

      const handleLogin = (username, password) => {
        setAuthError(''); setAuthMessage('');
        const user = users.find(u => u.username.toLowerCase() === username.toLowerCase());
        if(!user){ setAuthError('Benutzer existiert nicht.'); return; }
        if(!passwordsMatch(user.passwordHash, password)){ setAuthError('Passwort ist falsch.'); return; }
        setSessionState(prev => ({ ...(prev || {}), activeUserId: user.id }));
      };

      const handleRegister = (username, password) => {
        setAuthError(''); setAuthMessage('');
        if(users.some(u => u.username.toLowerCase() === username.toLowerCase())){ setAuthError('Benutzername bereits vergeben.'); return; }
        const newUser = { id: generateId('user'), username, passwordHash: hashPassword(password), role:'user', createdAt:new Date().toISOString() };
        setUsers(prev => [...prev, newUser]);
        setSessionState(prev => ({ ...(prev || {}), activeUserId: newUser.id }));
        setAuthMessage('Konto erstellt. Sie sind angemeldet.');
      };

      const handleLogout = () => {
        setSessionState(prev => ({ ...(prev || {}), activeUserId: null }));
        setAuthError('');
        setAuthMessage('');
      };

      const handlePasswordChange = (current, next) => {
        if(!activeUser) return { ok:false, error:'Kein aktiver Nutzer.' };
        if(!passwordsMatch(activeUser.passwordHash, current)){
          return { ok:false, error:'Aktuelles Passwort ist falsch.' };
        }
        const newHash = hashPassword(next);
        setUsers(prev => prev.map(u => u.id === activeUser.id ? { ...u, passwordHash: newHash } : u));
        return { ok:true };
      };

      const sessionValue = useMemo(()=>({
        activeUser,
        users,
        setUsers,
        setActiveUserId: (id) => setSessionState(prev => ({ ...(prev || {}), activeUserId: id }))
      }),[activeUser, users, setUsers, setSessionState]);

      return (
        <SessionContext.Provider value={sessionValue}>
          {activeUser ? (
            <MainApp onLogout={handleLogout} onChangePassword={handlePasswordChange} />
          ) : (
            <AuthScreen onLogin={handleLogin} onRegister={handleRegister} message={authMessage} error={authError} />
          )}
        </SessionContext.Provider>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<Root />);
  </script>
</body>
</html>
