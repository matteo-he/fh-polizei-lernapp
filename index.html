<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title> Lerntool E1 / E2a (Single-File)</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React & ReactDOM UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel (JSX im Browser) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Chart.js CDN (fÃ¼r Donut + Verlauf) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    // ========= Utils =========
    function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0}}
    function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
    function seededShuffle(array, seedStr){const seed=xmur3(seedStr)();const rng=mulberry32(seed);const a=[...array];for(let i=a.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a}
    const todayStr = () => new Date().toISOString().slice(0,10);

    // ========= Farben / Gruppen =========
    const COLOR = {
      BDG: { bg:"bg-yellow-50", border:"border-yellow-400", bar:"bg-yellow-400", grad:"from-yellow-400 to-amber-500", text:"text-yellow-700" },
      SPG: { bg:"bg-blue-50",   border:"border-blue-500",   bar:"bg-blue-500",   grad:"from-blue-600 to-indigo-600", text:"text-blue-700" },
      StPO:{ bg:"bg-red-50",    border:"border-red-500",    bar:"bg-red-500",    grad:"from-rose-600 to-red-600", text:"text-red-700" },
      StGB:{ bg:"bg-red-50",    border:"border-red-500",    bar:"bg-red-500",    grad:"from-rose-600 to-red-600", text:"text-red-700" },
      ADMIN:{ bg:"bg-green-50",  border:"border-green-600",  bar:"bg-green-600",  grad:"from-emerald-600 to-green-600", text:"text-green-700" },
    };
    const GROUPS = [
      { key:"BDG",   title:"Dienstrecht (BDG)",       tags:["BDG"],                color:COLOR.BDG },
      { key:"SPG",   title:"Sicherheitspolizei (SPG)",tags:["SPG"],                color:COLOR.SPG },
      { key:"STPO",  title:"Strafprozess/StGB",       tags:["StPO","StGB"],       color:COLOR.StPO },
      { key:"ADMIN", title:"Verwaltung & Verkehr",    tags:["AVG","VStG","WaffG","StVO","KFG","FSG"], color:COLOR.ADMIN },
    ];
    const ALL_TAGS = GROUPS.flatMap(g=>g.tags);

    const RANKS = [
      { title: "AnwÃ¤rter:in", min: 0 },
      { title: "Inspektor:in", min: 150 },
      { title: "Gruppeninspektor:in", min: 400 },
      { title: "Revierinspektor:in", min: 800 },
      { title: "Abteilungsinspektor:in", min: 1300 },
      { title: "Chefinspektor:in", min: 2000 },
    ];
    const rankFor = (score)=>[...RANKS].reverse().find(r=>score>=r.min)?.title || RANKS[0].title;

    function ProgressBar({ value, className="" }){
      // Farbwechsel nach Quote
      const v = Math.max(0, Math.min(100, value));
      const barColor = v>=80? "bg-green-600" : v>=50? "bg-yellow-500" : "bg-red-500";
      return (
        <div className={`w-full h-2 bg-gray-200 rounded-full overflow-hidden ${className}`}>
          <div className={`h-2 ${barColor} transition-all`} style={{ width: `${v}%` }} />
        </div>
      );
    }
    const Chip = ({children, className=""}) => <span className={`px-2 py-1 text-xs rounded-full border mr-2 mb-2 inline-block ${className}`}>{children}</span>;

    // ========= Demo-Fragen (du importierst dann deine JSON) =========
    const DEFAULT_QUESTIONS = [
      { id: "bdg-44-001", question:"Â§ 44 BDG: In welchen FÃ¤llen ist gegen eine Weisung zu remonstrieren oder darf ihre Befolgung abgelehnt werden?",
        choices:["Wenn der Inhalt unklar bleibt, obwohl nachgefragt wurde.","Wenn die Befolgung gegen strafrechtliche Vorschriften verstieÃŸe.","Wenn sie von einem unzustÃ¤ndigen Organ erteilt wurde.","Wenn die Weisung mÃ¼ndlich erteilt wurde.","Wenn die Befolgung gegen verwaltungsrechtliche Vorschriften verstieÃŸe."],
        correct:[0,1,2,4], explain:"UnzustÃ¤ndigkeit, Rechtswidrigkeit und unklarer Inhalt begrÃ¼nden Remonstration; MÃ¼ndlichkeit allein nicht.", law_ref:"BDG Â§ 44", tags:["BDG"], last_checked: todayStr(), difficulty:1 },
      { id:"bdg-39-001", question:"Â§ 39 BDG (Dienstzuteilung): Wann ist eine Dienstzuteilung ohne schriftliche Zustimmung Ã¼ber 90 Tage zulÃ¤ssig?",
        choices:["Zur Aufrechterhaltung des Dienstbetriebs.","Zu Ausbildungszwecken.","Bei wichtigen privaten GrÃ¼nden.","Wenn die Zuteilungsdienststelle zustimmt.","Wenn die entsendende Dienststelle zustimmt."],
        correct:[0,1], explain:">90 Tage ohne Zustimmung: nur Betriebsnotwendigkeit oder Ausbildung.", law_ref:"BDG Â§ 39", tags:["BDG"], last_checked: todayStr(), difficulty:2 }
    ];

    // ========= Local Storage Helpers =========
    function useLocalStorage(key, initial){
      const [state,setState]=useState(()=>{try{const s=localStorage.getItem(key);return s?JSON.parse(s):initial;}catch{return initial;}});
      useEffect(()=>{try{localStorage.setItem(key,JSON.stringify(state));}catch{}},[key,state]);
      return [state,setState];
    }

    // Persistente Fragenbank
    function useQuestions(){
      const [questions, setQuestions] = React.useState(() => {
        try {
          const saved = JSON.parse(localStorage.getItem('questions') || 'null');
          return (saved && Array.isArray(saved)) ? saved : DEFAULT_QUESTIONS;
        } catch { return DEFAULT_QUESTIONS; }
      });
      React.useEffect(() => {
        try { localStorage.setItem('questions', JSON.stringify(questions)); } catch {}
      }, [questions]);
      return { questions, setQuestions };
    }

    // ========= Lernmetriken (persistiert) =========
    const emptyMetrics = () => ({
      totalAttempts: 0,
      totalCorrect: 0,
      attemptedIds: {},     // id -> count
      correctIds: {},       // id -> count (exakt richtig)
      perTag: Object.fromEntries(ALL_TAGS.map(t=>[t,{attempts:0, correct:0}])),
      daily: {},            // YYYY-MM-DD -> {attempts, correct}
      secondsLearned: 0
    });
    function loadMetrics(){
      try { return JSON.parse(localStorage.getItem("metrics_v2") || "null") || emptyMetrics(); }
      catch { return emptyMetrics(); }
    }
    function saveMetrics(m){ try{ localStorage.setItem("metrics_v2", JSON.stringify(m)); }catch{} }

    // ========= Spaced Repetition (Tiers) =========
    const MIN_TIER=1, MAX_TIER=5;
    const getTierMap=()=>{try{return JSON.parse(localStorage.getItem('tiers')||'{}')}catch{return{}}};
    const setTierMap=(m)=>{try{localStorage.setItem('tiers',JSON.stringify(m))}catch{}};
    const getTier=(id)=>{const m=getTierMap();return m[id]||2};
    const setTier=(id,t)=>{const m=getTierMap();m[id]=Math.max(MIN_TIER,Math.min(MAX_TIER,t));setTierMap(m)};
    const tierWeight=(tier)=>({1:5,2:3,3:2,4:1.2,5:1}[tier]||1);
    function weightedOrder(items){return [...items].map(x=>({x,k:Math.random()**(1/tierWeight(getTier(x.id)))})).sort((a,b)=>b.k-a.k).map(o=>o.x)}
    const getDisplayOrder=(qid,idx)=> seededShuffle([0,1,2,3,4], `${qid}#${idx}`);

    // ========= Chart Komponente =========
    function DoughnutChart({ correct, wrong, open }){
      const ref = useRef(null);
      useEffect(()=>{
        const ctx = ref.current.getContext('2d');
        const chart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['Richtig','Falsch','Offen'],
            datasets: [{ data: [correct, wrong, open] }]
          },
          options: {
            plugins: { legend: { display: true, position: 'bottom' } },
            responsive: true,
            cutout: '60%'
          }
        });
        return ()=> chart.destroy();
      }, [correct, wrong, open]);
      return <canvas ref={ref} height="140"></canvas>;
    }

    function Sparkline({ points=[] }){
      const ref = useRef(null);
      useEffect(()=>{
        const labels = points.map(p=>p.d.slice(5)); // MM-DD
        const dataA = points.map(p=>p.a);
        const dataC = points.map(p=>p.c);
        const ctx = ref.current.getContext('2d');
        const chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              { label:'Versuche', data:dataA, fill:false, tension:0.3 },
              { label:'Richtig',  data:dataC, fill:false, tension:0.3 }
            ]
          },
          options: {
            plugins: { legend: { display: true, position: 'bottom' } },
            responsive: true
          }
        });
        return ()=> chart.destroy();
      }, [points]);
      return <canvas ref={ref} height="160"></canvas>;
    }

    // ========= Dashboard Karten =========
    function StatCard({ title, value, sub="" }){
      return (
        <div className="rounded-2xl p-4 bg-white shadow">
          <div className="text-xs text-gray-500">{title}</div>
          <div className="text-2xl font-bold mt-1">{value}</div>
          {sub && <div className="text-xs text-gray-500 mt-1">{sub}</div>}
        </div>
      );
    }

    function TopicProgress({ questions, metrics }){
      // Aggregiere je Gruppe
      const groups = GROUPS.map(g=>{
        const ids = questions.filter(q=>q.tags.some(t=>g.tags.includes(t))).map(q=>q.id);
        const attempts = ids.reduce((sum,id)=> sum + (metrics.attemptedIds[id]||0), 0);
        const correct  = ids.reduce((sum,id)=> sum + (metrics.correctIds[id]||0), 0);
        const total    = ids.length;
        const uniqueAttempted = ids.filter(id=> (metrics.attemptedIds[id]||0) > 0).length;
        const coverage = total? Math.round((uniqueAttempted/total)*100):0;
        const acc = attempts? Math.round((correct/attempts)*100):0;
        return { key:g.key, title:g.title, color:g.color, total, attempts, correct, coverage, acc };
      });

      return (
        <div className="grid md:grid-cols-4 sm:grid-cols-2 grid-cols-1 gap-4">
          {groups.map(c=>(
            <div key={c.key} className={`rounded-2xl p-4 border shadow ${c.color.bg} ${c.color.border}`}>
              <div className={`text-sm font-semibold ${c.color.text}`}>{c.title}</div>
              <div className="mt-1 text-xs text-gray-600">Fragen gesamt: {c.total}</div>
              <div className="mt-3">
                <div className="text-xs mb-1">Abdeckung (einmal gesehen)</div>
                <div className="w-full h-2 bg-white/70 rounded-full overflow-hidden border">
                  <div className={`h-2 ${c.color.bar}`} style={{ width: `${c.coverage}%`}} />
                </div>
              </div>
              <div className="mt-2">
                <div className="text-xs mb-1">Trefferquote</div>
                <div className="w-full h-2 bg-white/70 rounded-full overflow-hidden border">
                  <div className={`h-2 ${c.color.bar}`} style={{ width: `${c.acc}%`}} />
                </div>
              </div>
              <div className="mt-2 text-xs text-gray-600">Versuche: {c.attempts} Â· Richtig: {c.correct}</div>
            </div>
          ))}
        </div>
      );
    }

    function MissionControl({ questions, metrics, score, streak }){
      const total = questions.length;
      const attemptedUnique = Object.keys(metrics.attemptedIds).length;
      const open = Math.max(0, total - attemptedUnique);
      const attempts = metrics.totalAttempts;
      const correct = metrics.totalCorrect;
      const wrong = Math.max(0, attempts - correct);
      const accuracy = attempts? Math.round((correct/attempts)*100) : 0;
      const errorRate = attempts? (100 - accuracy) : 0;
      const rank = rankFor(score);

      // Verlauf letzte 7 Tage
      const last7 = [];
      for(let i=6;i>=0;i--){
        const d = new Date(); d.setDate(d.getDate()-i);
        const key = d.toISOString().slice(0,10);
        const day = metrics.daily[key] || {attempts:0, correct:0};
        last7.push({ d:key, a:day.attempts, c:day.correct });
      }

      return (
        <div className="space-y-6">
          <div className="grid lg:grid-cols-4 sm:grid-cols-2 grid-cols-1 gap-4">
            <StatCard title="Trefferquote" value={`${accuracy}%`} sub={`Fehlerquote ${errorRate}%`} />
            <StatCard title="Gesamt beantwortet" value={attempts} sub={`Richtig ${correct} Â· Falsch ${wrong}`} />
            <StatCard title="Streak" value={`${streak} ðŸ”¥`} sub="in Folge richtig" />
            <StatCard title="Rang" value={rank} sub={`${score} XP`} />
          </div>

          <div className="grid md:grid-cols-2 gap-4">
            <div className="rounded-2xl p-4 bg-white shadow">
              <div className="text-sm font-semibold mb-2">Ãœbersicht Richtig/Falsch/Offen</div>
              <DoughnutChart correct={correct} wrong={wrong} open={open}/>
            </div>
            <div className="rounded-2xl p-4 bg-white shadow">
              <div className="text-sm font-semibold mb-2">Deine Lernkurve (7 Tage)</div>
              <Sparkline points={last7}/>
            </div>
          </div>

          <div className="rounded-2xl p-4 bg-white shadow">
            <div className="text-sm font-semibold mb-3">Themen-Fortschritt</div>
            <TopicProgress questions={questions} metrics={metrics}/>
          </div>
        </div>
      );
    }

    // ========= Fragekarte =========
    function QuestionCard({ q, idx, submitted, onSubmit, onNext }){
      const [selectedDisplay, setSelectedDisplay] = useState([]);
      const displayOrder = useMemo(()=> getDisplayOrder(q.id, idx), [q.id, idx]);
      useEffect(()=>{ setSelectedDisplay([]); }, [q.id, idx]);
      const toggle = (dispIdx) => setSelectedDisplay(prev => prev.includes(dispIdx)? prev.filter(x=>x!==dispIdx):[...prev, dispIdx]);
      const correctSet = new Set(q.correct);
      const group = GROUPS.find(g=>q.tags.some(t=>g.tags.includes(t))) || GROUPS[GROUPS.length-1];

      return (
        <div className="bg-white rounded-2xl shadow p-0 overflow-hidden">
          <div className={`h-2 w-full bg-gradient-to-r ${group.color.grad}`} />
          <div className="p-6">
            <div className="mb-3 text-xs text-gray-500 flex flex-wrap items-center gap-2">
              {q.tags.map(t => (<Chip key={t} className={`${group.color.bg} ${group.color.border} ${group.color.text}`}>{t}</Chip>))}
              <Chip>Schwierigkeit {q.difficulty}</Chip>
              <Chip>Stand {q.last_checked}</Chip>
              <Chip>Tier {getTier(q.id)}</Chip>
            </div>
            <h2 className="text-lg font-semibold mb-4">{q.question}</h2>
            <div className="grid gap-2">
              {displayOrder.map((origIdx, dispIdx) => {
                const isChosen = selectedDisplay.includes(dispIdx);
                const isCorrect = correctSet.has(origIdx);
                const show = submitted;
                let classes = "text-left px-4 py-3 rounded-xl border transition flex items-start gap-3";
                if (show) {
                  classes += isCorrect ? " border-green-600 bg-green-50" : (isChosen ? " border-red-600 bg-red-50" : " bg-white");
                } else {
                  classes += " bg-white hover:bg-gray-50";
                }
                return (
                  <label key={dispIdx} className={classes}>
                    <input type="checkbox" className="mt-1" disabled={submitted} checked={isChosen} onChange={()=>toggle(dispIdx)} />
                    <span><span className="font-medium mr-2">{String.fromCharCode(65+dispIdx)}.</span>{q.choices[origIdx]}</span>
                  </label>
                );
              })}
            </div>
            {!submitted ? (
              <div className="mt-4 flex gap-2">
                <button className="px-3 py-2 rounded-lg border" onClick={() => onSubmit(selectedDisplay)}>Antwort abgeben</button>
                <button className="px-3 py-2 rounded-lg border" onClick={onNext}>Ãœberspringen</button>
              </div>
            ) : (
              <div className="mt-4 p-4 border rounded-xl bg-gray-50">
                <div className="text-sm">
                  <div className="font-semibold mb-1">AuflÃ¶sung & ErlÃ¤uterung</div>
                  <p className="mb-2">{q.explain}</p>
                  <div className="text-xs text-gray-600">Rechtsgrundlage: {q.law_ref}</div>
                </div>
                <div className="mt-3 flex gap-2">
                  <button className="px-3 py-2 rounded-lg border" onClick={onNext}>Weiter</button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    // ========= App =========
    function App(){
      const { questions: QUESTIONS, setQuestions } = useQuestions();
      const [view, setView] = useLocalStorage("view","dashboard"); // 'dashboard' | 'train'
      const [mode, setMode] = useLocalStorage("mode","training");
      const [seed, setSeed] = useState(0);
      const [filter, setFilter] = useLocalStorage("filter", { tags: [], difficulty: 0 });
      const [review, setReview] = useLocalStorage("review", []);
      const [score, setScore] = useLocalStorage("score", 0);
      const [streak, setStreak] = useLocalStorage("streak", 0);
      const [idx, setIdx] = useLocalStorage("idx", 0);
      const [showExplain, setShowExplain] = useState(false);
      const [metrics, setMetrics] = useState(loadMetrics());

      // Lernzeit (grob): pro sichtbarer Frage ~5s; hier tickend
      useEffect(()=>{
        const t = setInterval(()=>{
          const m = {...metrics}; m.secondsLearned += 1; setMetrics(m); saveMetrics(m);
        }, 1000);
        return ()=> clearInterval(t);
      }, [metrics]);

      const pool = useMemo(()=>{
        let p=QUESTIONS;
        if (filter.tags?.length) p=p.filter(q=>q.tags.some(t=>filter.tags.includes(t)));
        if (filter.difficulty) p=p.filter(q=>q.difficulty===filter.difficulty);
        if (mode==="mission"){ const firstTag=filter.tags[0]||"BDG"; p=p.filter(q=>q.tags.includes(firstTag)); }
        return weightedOrder(p);
      },[mode,filter,seed,QUESTIONS]);

      const current = pool[idx % (pool.length || 1)];

      function submitAnswer(selectedDisplayIdx){
        if(!current) return;
        const displayOrder=getDisplayOrder(current.id,idx);
        const toOriginal=(i)=>displayOrder[i];
        const selectedOriginalIdx=selectedDisplayIdx.map(toOriginal);

        const correctSet=new Set(current.correct);
        const selectedSet=new Set(selectedOriginalIdx);
        const allOptions=current.choices.map((_,i)=>i);
        const isExact=allOptions.every(i=>correctSet.has(i)===selectedSet.has(i));

        // Update Tiers + Punkte
        const curTier=getTier(current.id);
        if(isExact){ setScore(s=>s+10); setStreak(s=>s+1); setReview(r=>r.filter(id=>id!==current.id)); setTier(current.id,curTier+1); }
        else { setStreak(0); setReview(r=>(r.includes(current.id)?r:[...r,current.id])); setTier(current.id,curTier-1); }

        // Update Metrics
        const m = loadMetrics();
        m.totalAttempts += 1;
        if(isExact) m.totalCorrect += 1;
        m.attemptedIds[current.id] = (m.attemptedIds[current.id]||0) + 1;
        if(isExact) m.correctIds[current.id] = (m.correctIds[current.id]||0) + 1;
        current.tags.forEach(t=>{
          if(!m.perTag[t]) m.perTag[t] = {attempts:0, correct:0};
          m.perTag[t].attempts += 1;
          if(isExact) m.perTag[t].correct += 1;
        });
        const d = todayStr();
        if(!m.daily[d]) m.daily[d] = { attempts:0, correct:0 };
        m.daily[d].attempts += 1;
        if(isExact) m.daily[d].correct += 1;

        saveMetrics(m); setMetrics(m);

        setShowExplain(true);
      }
      function next(){ setIdx(i=>i+1); setShowExplain(false); }
      const progress=((idx % (pool.length||1))/(pool.length||1))*100;

      return (
        <div className="max-w-6xl mx-auto p-6">
          {/* Header */}
          <header className="mb-6">
            <div className="rounded-2xl p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow flex flex-wrap items-center gap-4 justify-between">
              <div>
                <h1 className="text-2xl font-bold">FH WN â€“ Polizeiliche FÃ¼hrung</h1>
                <p className="text-sm opacity-90">PrÃ¼fungsrealistisches MC-Training Â· 5 Optionen Â· Mehrfachauswahl Â· Antwortmischung Â· Spaced Repetition</p>
              </div>
              <div className="flex gap-2">
                <button onClick={()=>setView('dashboard')} className={`px-3 py-1 rounded-full border ${view==='dashboard'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Dashboard</button>
                <button onClick={()=>setView('train')} className={`px-3 py-1 rounded-full border ${view==='train'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Training</button>
              </div>
            </div>
          </header>

          {view==='dashboard' && (
            <MissionControl questions={QUESTIONS} metrics={metrics} score={score} streak={streak} />
          )}

          {view==='train' && (
            <>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                <div className="p-4 bg-white rounded-2xl shadow">
                  <div className="text-xs text-gray-500">Modus</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {["training","exam","mission"].map(val => (
                      <button key={val} onClick={() => setMode(val)} className={`px-3 py-1 rounded-full border ${mode===val?"bg-blue-600 text-white":"bg-white"}`}>{val}</button>
                    ))}
                  </div>
                </div>
                <div className="p-4 bg-white rounded-2xl shadow">
                  <div className="text-xs text-gray-500">Filter</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {ALL_TAGS.map(t => (
                      <button key={t} onClick={() => setFilter(f => ({...f, tags: f.tags.includes(t)? f.tags.filter(x=>x!==t):[...f.tags,t]}))}
                        className={`px-3 py-1 rounded-full border ${filter.tags.includes(t)?"bg-blue-100 border-blue-400":"bg-white"}`}>{t}</button>
                    ))}
                    <select className="ml-auto px-2 py-1 border rounded-full" value={filter.difficulty||0}
                      onChange={e=>setFilter(f=>({...f, difficulty: Number(e.target.value)}))}>
                      <option value={0}>Alle Schwierigkeitsgrade</option>
                      <option value={1}>Leicht</option>
                      <option value={2}>Mittel</option>
                      <option value={3}>Schwer</option>
                    </select>
                  </div>
                </div>
                <div className="p-4 bg-white rounded-2xl shadow">
                  <div className="text-xs text-gray-500">Einstellungen</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    <button className="px-3 py-1 rounded-lg border" onClick={()=>{
                      ['tiers','answers','score','streak','idx','review','filter','mode','questions','metrics_v2'].forEach(k=>localStorage.removeItem(k));
                      alert('ZurÃ¼ckgesetzt. Seite lÃ¤dt neu.'); location.reload();
                    }}>Fortschritt zurÃ¼cksetzen</button>
                  </div>
                </div>
              </div>

              {/* Fortschrittsleiste im aktuellen Ãœbungs-Pool */}
              <div className="mb-4 bg-white rounded-2xl shadow p-4">
                <div className="flex items-center justify-between text-sm mb-2">
                  <span>Ãœbungs-Fortschritt in aktuellem Pool</span>
                  <span>{Math.round(progress)}%</span>
                </div>
                <ProgressBar value={progress}/>
              </div>

              {current ? (
                <QuestionCard q={current} idx={idx} submitted={showExplain} onSubmit={submitAnswer} onNext={next} />
              ) : (
                <div className="bg-white rounded-2xl shadow p-6">Keine Fragen im aktuellen Filter.</div>
              )}

              <div className="mt-8 bg-white rounded-2xl shadow p-6">
                <h3 className="font-semibold mb-2">Fragen importieren/exportieren (JSON)</h3>
                <p className="text-sm text-gray-600 mb-3">Format: [{"{"}"id","question","choices":[5],"correct":[0,2,4],"explain":"...","law_ref":"...","tags":[...],"last_checked":"YYYY-MM-DD","difficulty":1{"}"}]</p>
                <div className="flex gap-2 flex-wrap">
                  <button className="px-3 py-2 rounded-lg border" onClick={() => {
                    const blob = new Blob([JSON.stringify(QUESTIONS, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'fragenbank.json'; a.click(); URL.revokeObjectURL(url);
                  }}>Export</button>

                  <label className="px-3 py-2 rounded-lg border cursor-pointer">Import
                    <input type="file" accept="application/json" className="hidden" onChange={async (e)=>{
                      const file=e.target.files?.[0]; if(!file) return; const text=await file.text();
                      try{
                        const data=JSON.parse(text);
                        const ok = Array.isArray(data) && data.every(q =>
                          q && typeof q.id==="string" && typeof q.question==="string" &&
                          Array.isArray(q.choices) && q.choices.length===5 &&
                          Array.isArray(q.correct) && q.correct.every(n=>Number.isInteger(n)&&n>=0&&n<5) &&
                          Array.isArray(q.tags)
                        );
                        if(!ok){ alert('UngÃ¼ltiges Format.'); return; }
                        setQuestions(data);
                        alert(`Import erfolgreich: ${data.length} Fragen Ã¼bernommen.`);
                      }catch{ alert('UngÃ¼ltiges JSON'); }
                    }}/>
                  </label>
                </div>
              </div>
            </>
          )}

          <footer className="text-xs text-gray-500 mt-8 mb-4 text-center">
            Stand: {new Date().toISOString().slice(0,10)} Â· Antwortmischung aktiv Â· Spaced Repetition (Tiers 1â€“5) Â· Farbcode je Rechtsgebiet
          </footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
