<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lerntool E1 / E2a</title>
  <!-- Tailwind über CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: 'class' };</script>
  <!-- React & ReactDOM UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel (damit JSX direkt im Browser funktioniert) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Firebase (modulares SDK) -->
  <script type="module">
    import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
    import { getFirestore, collection, doc, writeBatch, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDLH5c69JKeFWcJyBpzRUfv720KjnnRIU8",
      authDomain: "e1-und-e2a-lerntool.firebaseapp.com",
      projectId: "e1-und-e2a-lerntool",
      storageBucket: "e1-und-e2a-lerntool.firebasestorage.app",
      messagingSenderId: "28649721297",
      appId: "1:28649721297:web:432abbe98e34dd50fc24f0"
    };

    function ensureApp(){
      return getApps().length ? getApp() : initializeApp(firebaseConfig);
    }

    const app = ensureApp();
    const db = getFirestore(app);
    const auth = getAuth(app);

    let resolveAuthReady;
    let rejectAuthReady;
    let authReady;

    const resetAuthReady = () => {
      authReady = new Promise((resolve, reject) => {
        resolveAuthReady = resolve;
        rejectAuthReady = reject;
      });
    };

    const triggerAnonSignIn = () => {
      signInAnonymously(auth).catch((error) => {
        console.error('[Firebase] Anonyme Anmeldung fehlgeschlagen', error);
        if(typeof rejectAuthReady === 'function'){
          rejectAuthReady(error);
        }
        resetAuthReady();
      });
    };

    resetAuthReady();

    onAuthStateChanged(auth, (user) => {
      if(user && typeof resolveAuthReady === 'function'){
        resolveAuthReady(user);
        resolveAuthReady = null;
        rejectAuthReady = null;
      }
    }, (error) => {
      console.error('[Firebase] Auth-Listener-Fehler', error);
      if(typeof rejectAuthReady === 'function'){
        rejectAuthReady(error);
      }
      resetAuthReady();
    });

    triggerAnonSignIn();

    async function ensureAuthUser(){
      if(auth.currentUser) return auth.currentUser;
      try{
        return await authReady;
      }catch(error){
        console.warn('[Firebase] Auth nicht bereit, erneuter Anmeldeversuch …', error);
        resetAuthReady();
        triggerAnonSignIn();
        return authReady;
      }
    }

    window.FIREBASE_BRIDGE = {
      config: firebaseConfig,
      ensureApp,
      getFirestore,
      collection,
      doc,
      writeBatch,
      onSnapshot,
      setDoc,
      getAuth,
      onAuthStateChanged,
      signInAnonymously,
      ensureAuthUser,
      authReady,
      app,
      db,
      auth,
    };
    window.__FIREBASE_BRIDGE_READY__ = true;
    window.dispatchEvent(new Event('firebase-bridge-ready'));
  </script>
</head>
<body class="bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-100">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback } = React;

    const FIRESTORE_COLLECTION = "questions";
    const FIRESTORE_USERS_COLLECTION = "users";
    const FIRESTORE_PROGRESS_COLLECTION = "userProgress";

    const getFirebaseBridge = () => window.FIREBASE_BRIDGE || null;

    function getFirebaseConfigInfo(){
      const firebaseBridge = getFirebaseBridge();
      if(!firebaseBridge) return { config: null, isValid: false };
      const { config, app, db, ensureApp, getFirestore } = firebaseBridge;
      const hasConfig = config && typeof config === "object";
      const hasCore = typeof ensureApp === "function" && typeof getFirestore === "function";
      const hasInstances = !!app && !!db;
      return { config: hasConfig ? config : null, isValid: hasConfig && hasCore && hasInstances };
    }

    // ========= Utility =========
    function xmur3(str){
      let h = 1779033703 ^ str.length;
      for(let i=0;i<str.length;i++){
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = h << 13 | h >>> 19;
      }
      return function(){
        h = Math.imul(h ^ h >>> 16, 2246822507);
        h = Math.imul(h ^ h >>> 13, 3266489909);
        return (h ^ h >>> 16) >>> 0;
      };
    }

    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function seededShuffle(array, seedStr){
      const seed = xmur3(seedStr)();
      const rng = mulberry32(seed);
      const a = [...array];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rng()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function cloneValue(value){
      if (Array.isArray(value)) return value.map(cloneValue);
      if (value && typeof value === "object") return JSON.parse(JSON.stringify(value));
      return value;
    }

    function formatFirestoreError(error, fallbackMessage, options = {}){
      const fallback = typeof fallbackMessage === "string" && fallbackMessage.trim()
        ? fallbackMessage.trim()
        : "Ein unbekannter Firestore-Fehler ist aufgetreten.";
      if(!error || typeof error !== "object") return fallback;
      const details = [];
      if(typeof error.code === "string" && error.code.trim()){
        details.push(error.code.trim());
      }
      if(typeof error.message === "string" && error.message.trim()){
        const cleanedMessage = error.message.replace(/^.*?:\s*/, "").trim();
        if(cleanedMessage && !details.includes(cleanedMessage)){
          details.push(cleanedMessage);
        }
      }
      const detailText = details.length ? ` (${details.join(' – ')})` : "";
      if(details.includes('permission-denied')){
        const hint = typeof options.permissionDeniedHint === "string" && options.permissionDeniedHint.trim()
          ? options.permissionDeniedHint.trim()
          : "Firestore hat den Zugriff verweigert. Prüfe deine Sicherheitsregeln oder melde dich mit einem berechtigten Konto an.";
        return `${fallback} ${hint}${detailText}`;
      }
      return `${fallback}${detailText}`;
    }

    function ensureFiveChoices(list){
      const choices = Array.isArray(list) ? list.map(c => (typeof c === "string" ? c : "")).slice(0,5) : [];
      while(choices.length < 5){ choices.push(""); }
      return choices;
    }

    function sanitizeQuestionFromRemote(data, fallbackId){
      if(!data) return null;
      const id = typeof data.id === "string" && data.id.trim() ? data.id.trim() : (typeof fallbackId === "string" ? fallbackId : "");
      const questionText = typeof data.question === "string" ? data.question.trim() : "";
      if(!id || !questionText.trim()) return null;
      const choices = ensureFiveChoices(data.choices);
      const correct = Array.isArray(data.correct)
        ? Array.from(new Set(data.correct.filter(n => Number.isInteger(n) && n >= 0 && n < 5))).sort((a,b) => a-b)
        : [];
      const tags = Array.isArray(data.tags)
        ? data.tags.map(t => (typeof t === "string" ? t : String(t || ""))).map(t => t.trim()).filter(Boolean)
        : [];
      const difficultyRaw = Number(data.difficulty);
      const difficulty = Number.isFinite(difficultyRaw) ? Math.min(Math.max(Math.round(difficultyRaw), 1), 5) : 1;
      const lastChecked = typeof data.last_checked === "string" && data.last_checked.trim()
        ? data.last_checked.trim()
        : new Date().toISOString().slice(0,10);

      return {
        id,
        question: questionText,
        choices,
        correct,
        explain: typeof data.explain === "string" ? data.explain : "",
        law_ref: typeof data.law_ref === "string" ? data.law_ref : "",
        tags,
        last_checked: lastChecked,
        difficulty,
      };
    }

    function normalizeQuestionForStorage(question){
      if(!question || typeof question !== "object") return null;
      const normalized = sanitizeQuestionFromRemote(question, question.id || "");
      if(!normalized) return null;
      return {
        ...normalized,
        choices: normalized.choices.map(c => c.trim()),
        question: normalized.question.trim(),
        explain: normalized.explain.trim(),
        law_ref: normalized.law_ref.trim(),
      };
    }

    function sanitizeUserFromRemote(data, fallbackId){
      if(!data) return null;
      const id = typeof data.id === "string" && data.id.trim() ? data.id.trim() : (typeof fallbackId === "string" ? fallbackId : "");
      const username = typeof data.username === "string" ? data.username.trim() : "";
      const passwordHash = typeof data.passwordHash === "string" ? data.passwordHash.trim() : "";
      if(!id || !username || !passwordHash) return null;
      const role = data.role === "admin" ? "admin" : "user";
      return { id, username, passwordHash, role };
    }

    function normalizeUserForStorage(user){
      if(!user || typeof user !== "object") return null;
      const normalized = sanitizeUserFromRemote(user, user.id || "");
      if(!normalized) return null;
      return normalized;
    }

    function hashPassword(str=""){
      let hash = 0;
      for(let i=0;i<str.length;i++){
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return `h${Math.abs(hash)}`;
    }

    function passwordsMatch(hash, plain){
      return hash === hashPassword(plain);
    }

    function generateId(prefix="id"){
      const cleanPrefix = prefix.replace(/[^a-z0-9]+/gi, "").toLowerCase() || "id";
      return `${cleanPrefix}-${Math.random().toString(36).slice(2,8)}-${Date.now().toString(36)}`;
    }

    const ADMIN_SECRET = "POLIZEI-ADMIN";

    const COLOR = {
      BDG:   { bg:"bg-yellow-50", border:"border-yellow-400", bar:"bg-yellow-400", grad:"from-yellow-400 to-amber-500", text:"text-yellow-700 dark:text-yellow-200" },
      SPG:   { bg:"bg-blue-50",   border:"border-blue-500",   bar:"bg-blue-500",   grad:"from-blue-600 to-indigo-600", text:"text-blue-700 dark:text-blue-200" },
      StPO:  { bg:"bg-red-50",    border:"border-red-500",    bar:"bg-red-500",    grad:"from-rose-600 to-red-600", text:"text-red-700 dark:text-rose-200" },
      StGB:  { bg:"bg-red-50",    border:"border-red-500",    bar:"bg-red-500",    grad:"from-rose-600 to-red-600", text:"text-red-700 dark:text-rose-200" },
      ADMIN: { bg:"bg-green-50",  border:"border-green-600",  bar:"bg-green-600",  grad:"from-emerald-600 to-green-600", text:"text-green-700 dark:text-emerald-200" },
    };

    const GROUPS = [
      { key:"BDG",   title:"Dienstrecht (BDG)",           tags:["BDG"], color:COLOR.BDG },
      { key:"SPG",   title:"Sicherheitspolizei (SPG)",     tags:["SPG"], color:COLOR.SPG },
      { key:"STPO",  title:"Strafprozess/StGB",            tags:["StPO","StGB"], color:COLOR.StPO },
      { key:"ADMIN", title:"Verwaltung & Verkehr",          tags:["AVG","VStG","WaffG","StVO","KFG","FSG"], color:COLOR.ADMIN },
    ];

    const RANKS = [
      { title: "Anwärter:in", min: 0 },
      { title: "Inspektor:in", min: 150 },
      { title: "Gruppeninspektor:in", min: 400 },
      { title: "Revierinspektor:in", min: 800 },
      { title: "Abteilungsinspektor:in", min: 1300 },
      { title: "Chefinspektor:in", min: 2000 },
    ];

    const DEFAULT_QUESTIONS = [
      { id: "bdg-43-ma-1", question:"§ 43 BDG: Wie hat ein Beamter seine dienstlichen Aufgaben zu erfüllen? Wählen Sie alle zutreffenden.", choices:["Unter Beachtung der geltenden Rechtsordnung.","Treu, gewissenhaft, engagiert und unparteiisch.","Nur nach ständiger Rücksprache mit dem unmittelbaren Vorgesetzten.","So, dass das Vertrauen der Allgemeinheit erhalten bleibt.","Primär an interne Dienstanweisungen, nicht an Gesetze, gebunden."], correct:[0,1,3], explain:"§ 43 BDG: Rechtstreue, Gewissenhaftigkeit, Engagement, Unparteilichkeit und Wahrung des Vertrauens der Allgemeinheit.", law_ref:"BDG § 43", tags:["BDG"], last_checked:"2025-11-11", difficulty:1 },
      { id:"bdg-44-ma-1", question:"§ 44 BDG (Weisungen): In welchen Fällen ist zu remonstrieren/abzulehnen? Wählen Sie alle zutreffenden.", choices:["Wenn die Weisung von einem unzuständigen Organ erteilt wurde.","Wenn die Befolgung gegen verwaltungsrechtliche Vorschriften verstieße.","Wenn die Befolgung gegen strafrechtliche Vorschriften verstieße.","Wenn der Inhalt unklar ist und trotz Nachfrage unklar bleibt.","Wenn die Weisung mündlich erteilt wurde."], correct:[0,1,2,3], explain:"Unzuständigkeit oder Rechtswidrigkeit → Remonstrationspflicht; Mündlichkeit allein macht eine Weisung nicht unbeachtlich.", law_ref:"BDG § 44", tags:["BDG"], last_checked:"2025-11-11", difficulty:2 },
      { id:"bdg-43a-ma-1", question:"§ 43a BDG (achtungsvoller Umgang): Welche Aussagen treffen zu? Wählen Sie alle zutreffenden.", choices:["Beamte haben menschenwürdeverletzendes Verhalten zu unterlassen.","Vorgesetzte und Mitarbeiter begegnen einander mit Achtung.","Spontane Entgleisungen sind disziplinär immer irrelevant.","Vorgesetzte haben für achtungsvollen Umgang Sorge zu tragen.","§ 43a betrifft nur den Umgang mit Parteien."], correct:[0,1,3], explain:"§ 43a BDG verlangt würdevollen, diskriminierungsfreien Umgang; spontane Entgleisungen können relevant sein.", law_ref:"BDG § 43a", tags:["BDG"], last_checked:"2025-11-11", difficulty:1 },
      { id:"bdg-39-ma-1", question:"§ 39 BDG (Dienstzuteilung): Unter welchen Bedingungen ist eine Zuteilung ohne schriftliche Zustimmung über 90 Tage zulässig? Wählen Sie alle zutreffenden.", choices:["Wenn der Dienstbetrieb auf andere Weise nicht aufrechterhalten werden kann.","Wenn sie zum Zwecke einer Ausbildung erfolgt.","Wenn wichtige private Gründe vorliegen.","Wenn der Kommandant der entsendenden Dienststelle zustimmt.","Wenn der Kommandant der Zuteilungsdienststelle zustimmt."], correct:[0,1], explain:">90 Tage ohne Zustimmung: nur zur Aufrechterhaltung des Dienstbetriebs oder zu Ausbildungszwecken.", law_ref:"BDG § 39", tags:["BDG"], last_checked:"2025-11-11", difficulty:2 },
    ];

    const DEFAULT_FILTER = { tags: [], difficulty: 0 };
    const DEFAULT_METRICS = { totalAttempts: 0, totalCorrect: 0, attemptedIds: {}, correctIds: {} };

    // ========= Helpers =========
    function useLocalStorage(key, initial){
      const [state,setState]=useState(()=>{
        try{
          const stored = localStorage.getItem(key);
          if(stored !== null) return JSON.parse(stored);
        }catch{}
        return cloneValue(initial);
      });
      useEffect(()=>{
        try{ localStorage.setItem(key, JSON.stringify(state)); }catch{}
      },[key,state]);
      return [state,setState];
    }

    const sortUsersByName = (list) => {
      return Array.isArray(list)
        ? [...list].sort((a,b) => a.username.localeCompare(b.username))
        : [];
    };

    const sortQuestionsById = (list) => {
      return Array.isArray(list)
        ? [...list].sort((a,b) => a.id.localeCompare(b.id))
        : [];
    };

    function useUsers(){
      const [bridgeVersion, setBridgeVersion] = useState(() => window.__FIREBASE_BRIDGE_READY__ ? 1 : 0);
      const { config, isValid } = getFirebaseConfigInfo();
      const [usersState, setUsersState] = useState(() => {
        try{
          const saved = JSON.parse(localStorage.getItem("users") || "null");
          if(Array.isArray(saved) && saved.length){
            const sanitized = saved.map(item => normalizeUserForStorage(item)).filter(Boolean);
            const cleaned = sanitized.filter(u => !(u.username === "Admin" && u.role === "admin" && u.passwordHash === hashPassword("admin")));
            if(cleaned.length) return cleaned;
            if(sanitized.length) return [];
          }
        }catch{}
        return [];
      });
      const [isUsingFirestore, setIsUsingFirestore] = useState(false);
      const [isLoading, setIsLoading] = useState(isValid);
      const [syncError, setSyncError] = useState(null);

      const firestoreRef = React.useRef(null);
      const applyingRemote = React.useRef(false);
      const syncQueue = React.useRef(Promise.resolve());
      const usersStateRef = React.useRef(usersState);

      useEffect(() => {
        usersStateRef.current = usersState;
      }, [usersState]);

      useEffect(() => {
        const handler = () => setBridgeVersion(v => v + 1);
        window.addEventListener('firebase-bridge-ready', handler);
        if(window.__FIREBASE_BRIDGE_READY__){
          handler();
        }
        return () => window.removeEventListener('firebase-bridge-ready', handler);
      }, []);

      const persistLocal = useCallback((list) => {
        try{ localStorage.setItem("users", JSON.stringify(list)); }catch{}
      }, []);

      const pushChangesToFirestore = useCallback((previousList, nextList) => {
        const firebaseBridge = getFirebaseBridge();
        if(!firestoreRef.current || !firebaseBridge) return;
        const db = firestoreRef.current;
        const { writeBatch, doc } = firebaseBridge;
        if(typeof writeBatch !== "function" || typeof doc !== "function") return;

        const prevMap = new Map(previousList.map(u => [u.id, u]));
        const operations = [];

        previousList.forEach(u => {
          if(u && u.id && !nextList.some(n => n && n.id === u.id)){
            operations.push({ type: 'delete', id: u.id });
          }
        });

        nextList.forEach(u => {
          const normalized = normalizeUserForStorage(u);
          if(!normalized) return;
          const prevNormalized = prevMap.get(normalized.id);
          if(!prevNormalized || JSON.stringify(prevNormalized) !== JSON.stringify(normalized)){
            operations.push({ type: 'set', id: normalized.id, data: normalized });
          }
        });

        if(!operations.length){
          setSyncError(null);
          return;
        }

        syncQueue.current = syncQueue.current.then(async () => {
          for(let i = 0; i < operations.length; i += 450){
            const slice = operations.slice(i, i + 450);
            const batch = writeBatch(db);
            slice.forEach(op => {
              const docRef = doc(db, FIRESTORE_USERS_COLLECTION, op.id);
              if(op.type === 'delete') batch.delete(docRef);
              else batch.set(docRef, op.data);
            });
            await batch.commit();
          }
          setSyncError(null);
        }).catch(error => {
          console.error('[Firestore] Nutzer-Synchronisation fehlgeschlagen', error);
          setSyncError('Nutzer konnten nicht nach Firestore synchronisiert werden.');
        });
      }, []);

      useEffect(() => {
        const firebaseBridge = getFirebaseBridge();
        if(!isValid || !firebaseBridge){
          setIsLoading(false);
          setIsUsingFirestore(false);
          firestoreRef.current = null;
          return;
        }
        let unsubscribe = () => {};
        let cancelled = false;
        setIsLoading(true);
        (async () => {
          try{
            const { ensureApp, getFirestore, collection, onSnapshot, ensureAuthUser } = firebaseBridge;
            if(typeof ensureApp !== "function" || typeof getFirestore !== "function" || typeof collection !== "function" || typeof onSnapshot !== "function"){
              setIsLoading(false);
              setIsUsingFirestore(false);
              return;
            }
            if(typeof ensureAuthUser === "function"){
              await ensureAuthUser();
            }
            const app = ensureApp();
            const db = getFirestore(app);
            firestoreRef.current = db;
            syncQueue.current = Promise.resolve();
            const collectionRef = collection(db, FIRESTORE_USERS_COLLECTION);
            unsubscribe = onSnapshot(collectionRef, (snapshot) => {
              if(cancelled) return;
              const remoteUsers = sortUsersByName(
                snapshot.docs
                  .map(doc => sanitizeUserFromRemote(doc.data(), doc.id))
                  .filter(Boolean)
              );
              const cleaned = remoteUsers.filter(u => !(u.username === "Admin" && u.role === "admin" && u.passwordHash === hashPassword("admin")));
              const previousUsers = Array.isArray(usersStateRef.current) ? usersStateRef.current : [];
              let nextUsers = cleaned;
              if(!cleaned.length && previousUsers.length){
                nextUsers = sortUsersByName(previousUsers);
                pushChangesToFirestore(cleaned, nextUsers);
              } else if(cleaned.length){
                const remoteIds = new Set(cleaned.map(u => u.id));
                const missingLocals = sortUsersByName(
                  previousUsers
                    .map(item => normalizeUserForStorage(item))
                    .filter(Boolean)
                    .filter(localUser => !remoteIds.has(localUser.id))
                );
                if(missingLocals.length){
                  nextUsers = sortUsersByName([...cleaned, ...missingLocals]);
                  pushChangesToFirestore(cleaned, nextUsers);
                }
              }
              applyingRemote.current = true;
              setUsersState(nextUsers);
              applyingRemote.current = false;
              persistLocal(nextUsers);
              setIsUsingFirestore(true);
              setIsLoading(false);
              setSyncError(null);
            }, (error) => {
              if(cancelled) return;
              console.error('[Firestore] Nutzer-Listener-Fehler', error);
              setSyncError(formatFirestoreError(error, 'Nutzer konnten nicht aus Firestore geladen werden.', {
                permissionDeniedHint: `Firestore hat den Zugriff verweigert. Prüfe, ob deine Sicherheitsregeln die Collection "${FIRESTORE_USERS_COLLECTION}" freigeben (z. B. match /databases/{database}/documents/${FIRESTORE_USERS_COLLECTION}/{docId} { allow read: if true; }).`,
              }));
              setIsLoading(false);
            });
          }catch(error){
            if(cancelled) return;
            console.error('[Firestore] Nutzer-Initialisierung fehlgeschlagen', error);
            setSyncError(formatFirestoreError(error, 'Firestore konnte für Nutzer nicht initialisiert werden.', {
              permissionDeniedHint: `Firestore hat den Zugriff verweigert. Prüfe, ob deine Sicherheitsregeln die Collection "${FIRESTORE_USERS_COLLECTION}" freigeben (z. B. match /databases/{database}/documents/${FIRESTORE_USERS_COLLECTION}/{docId} { allow read: if true; }).`,
            }));
            setIsLoading(false);
          }
        })();
        return () => {
          cancelled = true;
          if(typeof unsubscribe === 'function') unsubscribe();
          firestoreRef.current = null;
        };
      }, [config, isValid, persistLocal, bridgeVersion, pushChangesToFirestore]);

      const setUsers = useCallback((updater) => {
        setUsersState(prevList => {
          const previous = Array.isArray(prevList) ? prevList : [];
          const inputForUpdater = cloneValue(previous);
          const resolved = typeof updater === 'function' ? updater(inputForUpdater) : updater;
          const nextSanitized = Array.isArray(resolved)
            ? resolved.map(item => normalizeUserForStorage(item)).filter(Boolean)
            : previous;
          const cleaned = nextSanitized.filter(u => !(u.username === "Admin" && u.role === "admin" && u.passwordHash === hashPassword("admin")));
          persistLocal(cleaned);
          if(firestoreRef.current && !applyingRemote.current){
            pushChangesToFirestore(previous, cleaned);
          }
          return cleaned;
        });
      }, [persistLocal, pushChangesToFirestore]);

      const meta = useMemo(() => ({ isUsingFirestore, isLoading, syncError }), [isUsingFirestore, isLoading, syncError]);

      return useMemo(() => Object.assign([usersState, setUsers], { meta }), [usersState, setUsers, meta]);
    }

    function useUserLocalStorage(userId, key, initial){
      const storageKey = userId ? `${userId}:${key}` : null;
      const stableInitial = useMemo(() => cloneValue(initial), [storageKey]);
      const [state, setState] = useState(() => cloneValue(stableInitial));
      const [bridgeVersion, setBridgeVersion] = useState(() => window.__FIREBASE_BRIDGE_READY__ ? 1 : 0);
      const [isUsingFirestore, setIsUsingFirestore] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [syncError, setSyncError] = useState(null);

      const firestoreFieldKey = useMemo(() => (userId ? `${userId}:${key}` : null), [userId, key]);

      const docRefRef = React.useRef(null);
      const applyingRemote = React.useRef(false);
      const syncQueue = React.useRef(Promise.resolve());
      const localValueRef = React.useRef(cloneValue(stableInitial));

      useEffect(() => {
        if(!storageKey){
          const fallback = cloneValue(stableInitial);
          setState(fallback);
          setIsUsingFirestore(false);
          setSyncError(null);
          localValueRef.current = fallback;
          return;
        }
        try{
          const raw = localStorage.getItem(storageKey);
          if(raw !== null){
            const parsed = JSON.parse(raw);
            setState(parsed);
            localValueRef.current = cloneValue(parsed);
          } else {
            const fallback = cloneValue(stableInitial);
            setState(fallback);
            localValueRef.current = fallback;
          }
        }catch{
          const fallback = cloneValue(stableInitial);
          setState(fallback);
          localValueRef.current = fallback;
        }
      }, [storageKey, stableInitial]);

      useEffect(() => {
        const handler = () => setBridgeVersion(v => v + 1);
        window.addEventListener('firebase-bridge-ready', handler);
        if(window.__FIREBASE_BRIDGE_READY__){
          handler();
        }
        return () => window.removeEventListener('firebase-bridge-ready', handler);
      }, []);

      const persistLocal = useCallback((value) => {
        if(!storageKey) return;
        localValueRef.current = cloneValue(value);
        try{ localStorage.setItem(storageKey, JSON.stringify(value)); }catch{}
      }, [storageKey]);

      useEffect(() => {
        if(!userId){
          setIsUsingFirestore(false);
          setIsLoading(false);
          docRefRef.current = null;
          return;
        }
        const firebaseBridge = getFirebaseBridge();
        if(!firebaseBridge){
          setIsUsingFirestore(false);
          setIsLoading(false);
          docRefRef.current = null;
          return;
        }
        const { ensureApp, getFirestore, doc, onSnapshot, setDoc, ensureAuthUser } = firebaseBridge;
        if(typeof ensureApp !== "function" || typeof getFirestore !== "function" || typeof doc !== "function" || typeof onSnapshot !== "function" || typeof setDoc !== "function"){
          setIsUsingFirestore(false);
          setIsLoading(false);
          docRefRef.current = null;
          return;
        }
        let unsubscribe = () => {};
        let cancelled = false;
        setIsLoading(true);
        (async () => {
          try{
            const authUser = typeof ensureAuthUser === "function" ? await ensureAuthUser() : null;
            if(!authUser || !authUser.uid){
              throw new Error('Kein Auth-User für Fortschritt verfügbar');
            }
            const app = ensureApp();
            const db = getFirestore(app);
            const docRef = doc(db, FIRESTORE_PROGRESS_COLLECTION, authUser.uid);
            docRefRef.current = docRef;
            syncQueue.current = Promise.resolve();
            unsubscribe = onSnapshot(docRef, (snapshot) => {
              if(cancelled) return;
              const data = snapshot.exists() ? (snapshot.data() || {}) : {};
              const hasKey = firestoreFieldKey && Object.prototype.hasOwnProperty.call(data, firestoreFieldKey);
              const remoteValue = hasKey ? cloneValue(data[firestoreFieldKey]) : cloneValue(localValueRef.current);
              applyingRemote.current = true;
              setState(remoteValue);
              applyingRemote.current = false;
              persistLocal(remoteValue);
              setIsUsingFirestore(true);
              setIsLoading(false);
              setSyncError(null);
              if(!hasKey){
                const docRefSnapshot = docRefRef.current;
                const firebaseBridge = getFirebaseBridge();
                if(docRefSnapshot && firebaseBridge && typeof firebaseBridge.setDoc === 'function' && firestoreFieldKey){
                  const { setDoc, ensureAuthUser } = firebaseBridge;
                  const payload = cloneValue(localValueRef.current);
                  syncQueue.current = syncQueue.current.then(async () => {
                    if(typeof ensureAuthUser === "function"){
                      await ensureAuthUser();
                    }
                    await setDoc(docRefSnapshot, { [firestoreFieldKey]: payload }, { merge: true });
                  }).catch(error => {
                    console.error('[Firestore] Fortschritt konnte nicht initial hochgeladen werden', error);
                    setSyncError('Lokaler Fortschritt konnte nicht nach Firestore übertragen werden.');
                  });
                }
              }
            }, (error) => {
              if(cancelled) return;
              console.error('[Firestore] Fortschritt-Listener-Fehler', error);
              setSyncError(formatFirestoreError(error, 'Fortschritt konnte nicht aus Firestore geladen werden.', {
                permissionDeniedHint: `Firestore hat den Zugriff verweigert. Prüfe, ob deine Sicherheitsregeln die Collection "${FIRESTORE_PROGRESS_COLLECTION}" freigeben (z. B. match /databases/{database}/documents/${FIRESTORE_PROGRESS_COLLECTION}/{docId} { allow read, write: if true; }).`,
              }));
              setIsLoading(false);
              if(!cancelled && error && error.code === 'permission-denied' && typeof ensureAuthUser === 'function'){
                ensureAuthUser().then(() => {
                  setBridgeVersion((v) => v + 1);
                }).catch((authError) => {
                  console.warn('[Firestore] Re-Auth nach Berechtigungsfehler fehlgeschlagen', authError);
                });
              }
            });
          }catch(error){
            if(cancelled) return;
            console.error('[Firestore] Fortschritt-Initialisierung fehlgeschlagen', error);
            setSyncError(formatFirestoreError(error, 'Firestore konnte für den Fortschritt nicht initialisiert werden.', {
              permissionDeniedHint: `Firestore hat den Zugriff verweigert. Prüfe, ob deine Sicherheitsregeln die Collection "${FIRESTORE_PROGRESS_COLLECTION}" freigeben (z. B. match /databases/{database}/documents/${FIRESTORE_PROGRESS_COLLECTION}/{docId} { allow read, write: if true; }).`,
            }));
            setIsLoading(false);
          }
        })();
        return () => {
          cancelled = true;
          if(typeof unsubscribe === 'function') unsubscribe();
          docRefRef.current = null;
        };
      }, [userId, key, persistLocal, bridgeVersion, firestoreFieldKey]);

      const setStateWithSync = useCallback((updater) => {
        setState(prevState => {
          const previous = cloneValue(prevState);
          const resolved = typeof updater === 'function' ? updater(previous) : updater;
          const next = cloneValue(resolved);
          persistLocal(next);
          const docRefSnapshot = docRefRef.current;
          if(docRefSnapshot && !applyingRemote.current && firestoreFieldKey){
            const firebaseBridge = getFirebaseBridge();
            if(firebaseBridge && typeof firebaseBridge.setDoc === 'function'){
              const { setDoc, ensureAuthUser } = firebaseBridge;
              const payload = cloneValue(next);
              syncQueue.current = syncQueue.current.then(async () => {
                if(typeof ensureAuthUser === "function"){
                  await ensureAuthUser();
                }
                await setDoc(docRefSnapshot, { [firestoreFieldKey]: payload }, { merge: true });
              }).then(() => {
                setSyncError(null);
                setIsUsingFirestore(true);
              }).catch(error => {
                console.error('[Firestore] Fortschritt konnte nicht gespeichert werden', error);
                setSyncError('Fortschritt konnte nicht nach Firestore geschrieben werden.');
              });
            }
          }
          return next;
        });
      }, [key, persistLocal, firestoreFieldKey]);

      const meta = useMemo(() => ({ isUsingFirestore, isLoading, syncError }), [isUsingFirestore, isLoading, syncError]);

      return useMemo(() => Object.assign([state, setStateWithSync], { meta }), [state, setStateWithSync, meta]);
    }

    function rankFor(score){
      const r=[...RANKS].reverse().find(r=>score>=r.min);
      return r? r.title : RANKS[0].title;
    }

    function tierWeight(tier){
      return ({1:5,2:3,3:2,4:1.2,5:1}[tier] || 1);
    }

    function weightedOrder(items, tierResolver, seedStr = "default"){
      const resolve = typeof tierResolver === "function" ? tierResolver : (()=>2);
      const seedFn = xmur3(String(seedStr || "default"));
      const rng = mulberry32(seedFn());
      return [...items]
        .map(x => ({ x, k: (rng() || Number.EPSILON) ** (1 / tierWeight(resolve(x.id))) }))
        .sort((a,b) => b.k - a.k)
        .map(o => o.x);
    }

    const getDisplayOrder = (qid, idx) => seededShuffle([0,1,2,3,4], `${qid}#${idx}`);

    function useQuestions(){
      const [bridgeVersion, setBridgeVersion] = useState(() => window.__FIREBASE_BRIDGE_READY__ ? 1 : 0);
      const { config, isValid } = getFirebaseConfigInfo();
      const [questionsState, setQuestionsState] = useState(() => {
        try {
          const saved = JSON.parse(localStorage.getItem('questions') || 'null');
          if(saved && Array.isArray(saved)){
            const sanitized = saved.map(item => normalizeQuestionForStorage(item)).filter(Boolean);
            if(sanitized.length) return sanitized;
          }
        } catch {}
        return DEFAULT_QUESTIONS.map(item => normalizeQuestionForStorage(item)).filter(Boolean);
      });
      const [isUsingFirestore, setIsUsingFirestore] = useState(false);
      const [isLoading, setIsLoading] = useState(isValid);
      const [syncError, setSyncError] = useState(null);

      const firestoreRef = React.useRef(null);
      const applyingRemote = React.useRef(false);
      const syncQueue = React.useRef(Promise.resolve());
      const questionsStateRef = React.useRef(questionsState);

      useEffect(() => {
        questionsStateRef.current = questionsState;
      }, [questionsState]);

      useEffect(() => {
        const handler = () => setBridgeVersion(v => v + 1);
        window.addEventListener('firebase-bridge-ready', handler);
        if(window.__FIREBASE_BRIDGE_READY__){
          handler();
        }
        return () => window.removeEventListener('firebase-bridge-ready', handler);
      }, []);

      const pushChangesToFirestore = useCallback((previousList, nextList) => {
        const firebaseBridge = getFirebaseBridge();
        if(!firestoreRef.current || !firebaseBridge) return;
        const db = firestoreRef.current;
        const { writeBatch, doc } = firebaseBridge;
        if(typeof writeBatch !== "function" || typeof doc !== "function") return;
        const prevMap = new Map(previousList.map(q => [q.id, q]));
        const operations = [];

        previousList.forEach(q => {
          if(q && q.id && !nextList.some(n => n && n.id === q.id)){
            operations.push({ type: 'delete', id: q.id });
          }
        });

        nextList.forEach(q => {
          const normalized = normalizeQuestionForStorage(q);
          if(!normalized) return;
          const prevNormalized = prevMap.get(normalized.id);
          if(!prevNormalized || JSON.stringify(prevNormalized) !== JSON.stringify(normalized)){
            operations.push({ type: 'set', id: normalized.id, data: normalized });
          }
        });

        if(!operations.length){
          setSyncError(null);
          return;
        }

        syncQueue.current = syncQueue.current.then(async () => {
          for(let i = 0; i < operations.length; i += 450){
            const slice = operations.slice(i, i + 450);
            const batch = writeBatch(db);
            slice.forEach(op => {
              const docRef = doc(db, FIRESTORE_COLLECTION, op.id);
              if(op.type === 'delete') batch.delete(docRef);
              else batch.set(docRef, op.data);
            });
            await batch.commit();
          }
          setSyncError(null);
        }).catch(error => {
          console.error('[Firestore] Synchronisation fehlgeschlagen', error);
          setSyncError('Änderungen konnten nicht nach Firestore geschrieben werden.');
        });
      }, []);

      const persistLocal = useCallback((list) => {
        try { localStorage.setItem('questions', JSON.stringify(list)); } catch {}
      }, []);

      useEffect(() => {
        const firebaseBridge = getFirebaseBridge();
        if(!isValid || !firebaseBridge){
          setIsLoading(false);
          setIsUsingFirestore(false);
          firestoreRef.current = null;
          return;
        }
        let unsubscribe = () => {};
        let cancelled = false;
        setIsLoading(true);
        (async () => {
          try {
            const { ensureApp, getFirestore, collection, onSnapshot, ensureAuthUser } = firebaseBridge;
            const app = ensureApp();
            if(typeof ensureAuthUser === 'function'){
              await ensureAuthUser();
            }
            const db = getFirestore(app);
            firestoreRef.current = db;
            syncQueue.current = Promise.resolve();
            const collectionRef = collection(db, FIRESTORE_COLLECTION);
            unsubscribe = onSnapshot(collectionRef, (snapshot) => {
              if(cancelled) return;
              const remoteQuestions = sortQuestionsById(
                snapshot.docs
                  .map(doc => sanitizeQuestionFromRemote(doc.data(), doc.id))
                  .filter(Boolean)
              );
              const previousQuestions = sortQuestionsById(Array.isArray(questionsStateRef.current) ? questionsStateRef.current : []);
              let nextQuestions = remoteQuestions;
              if(!remoteQuestions.length && previousQuestions.length){
                nextQuestions = previousQuestions;
                pushChangesToFirestore(remoteQuestions, nextQuestions);
              } else if(remoteQuestions.length){
                const remoteIds = new Set(remoteQuestions.map(q => q.id));
                const missingLocals = sortQuestionsById(
                  previousQuestions
                    .map(item => normalizeQuestionForStorage(item))
                    .filter(Boolean)
                    .filter(localQuestion => !remoteIds.has(localQuestion.id))
                );
                if(missingLocals.length){
                  nextQuestions = sortQuestionsById([...remoteQuestions, ...missingLocals]);
                  pushChangesToFirestore(remoteQuestions, nextQuestions);
                }
              }
              applyingRemote.current = true;
              setQuestionsState(nextQuestions);
              applyingRemote.current = false;
              persistLocal(nextQuestions);
              setIsUsingFirestore(true);
              setIsLoading(false);
              setSyncError(null);
            }, (error) => {
              if(cancelled) return;
              console.error('[Firestore] Echtzeit-Listener-Fehler', error);
              setSyncError(formatFirestoreError(error, 'Live-Aktualisierung aus Firestore fehlgeschlagen.', {
                permissionDeniedHint: `Firestore hat den Zugriff verweigert. Überprüfe, ob deine Sicherheitsregeln die Collection "${FIRESTORE_COLLECTION}" abdecken (z. B. match /databases/{database}/documents/${FIRESTORE_COLLECTION}/{docId} { allow read: if true; }). Melde dich alternativ mit einem berechtigten Konto an.`,
              }));
              setIsLoading(false);
            });
          } catch (error) {
            if(cancelled) return;
            console.error('[Firestore] Initialisierung fehlgeschlagen', error);
            setSyncError(formatFirestoreError(error, 'Firestore konnte nicht initialisiert werden.', {
              permissionDeniedHint: `Firestore hat den Zugriff verweigert. Überprüfe, ob deine Sicherheitsregeln die Collection "${FIRESTORE_COLLECTION}" abdecken (z. B. match /databases/{database}/documents/${FIRESTORE_COLLECTION}/{docId} { allow read: if true; }). Melde dich alternativ mit einem berechtigten Konto an.`,
            }));
            setIsLoading(false);
          }
        })();
        return () => {
          cancelled = true;
          if(typeof unsubscribe === 'function') unsubscribe();
          firestoreRef.current = null;
        };
      }, [config, isValid, persistLocal, bridgeVersion, pushChangesToFirestore]);

      const setQuestions = useCallback((updater) => {
        setQuestionsState(prevList => {
          const previous = Array.isArray(prevList) ? prevList : [];
          const inputForUpdater = cloneValue(previous);
          const resolved = typeof updater === 'function' ? updater(inputForUpdater) : updater;
          const nextSanitized = Array.isArray(resolved)
            ? resolved.map(item => normalizeQuestionForStorage(item)).filter(Boolean)
            : previous;
          persistLocal(nextSanitized);
          if(firestoreRef.current && !applyingRemote.current){
            pushChangesToFirestore(previous, nextSanitized);
          }
          return nextSanitized;
        });
      }, [persistLocal, pushChangesToFirestore]);

      return {
        questions: questionsState,
        setQuestions,
        isUsingFirestore,
        isLoading,
        syncError,
        firestoreConfigured: !!config,
        firebaseConfigValid: isValid,
      };
    }

    function Chip({ children, className="" }){
      return <span className={`px-2 py-1 text-xs rounded-full border mr-2 mb-2 inline-block ${className}`}>{children}</span>;
    }

    function StatCard({ title, value, sub }){
      return (
        <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow">
          <div className="text-xs text-gray-500 dark:text-gray-400">{title}</div>
          <div className="text-2xl font-semibold mt-1">{value}</div>
          {sub ? <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">{sub}</div> : null}
        </div>
      );
    }

    function Dashboard({ stats, rank, score, reviewCount }){
      const cards = GROUPS.map(g=>({ ...stats[g.key], key:g.key }));
      return (
        <div className="space-y-6">
          <div className="grid md:grid-cols-4 sm:grid-cols-2 grid-cols-1 gap-4">
            {cards.map(c=>{
              const attemptedPct = c.total? Math.round((c.attempted/c.total)*100):0;
              const correctPct   = c.attempted? Math.round((c.correct/c.attempted)*100):0;
              return (
                <div key={c.key} className={`rounded-2xl p-4 border shadow ${c.color.bg} ${c.color.border} dark:bg-gray-800 dark:border-gray-700`}>
                  <div className={`text-sm font-semibold ${c.color.text}`}>{GROUPS.find(g=>g.key===c.key).title}</div>
                  <div className="mt-2 text-xs text-gray-600 dark:text-gray-300">Fragen: {c.total} · Bearbeitet: {c.attempted} · Richtig: {c.correct}</div>
                  <div className="mt-3">
                    <div className="text-xs mb-1">Abdeckung</div>
                    <div className="w-full h-2 bg-white/70 rounded-full overflow-hidden border">
                      <div className={`h-2 ${c.color.bar}`} style={{ width: `${attemptedPct}%`}} />
                    </div>
                  </div>
                  <div className="mt-2">
                    <div className="text-xs mb-1">Trefferquote</div>
                    <div className="w-full h-2 bg-white/70 rounded-full overflow-hidden border">
                      <div className={`h-2 ${c.color.bar}`} style={{ width: `${correctPct}%`}} />
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
          <div className="grid md:grid-cols-3 gap-4">
            <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow"><div className="text-xs text-gray-500 dark:text-gray-400">Aktueller Rang</div><div className="text-2xl font-bold mt-1">{rank}</div></div>
            <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow"><div className="text-xs text-gray-500 dark:text-gray-400">Gesamtpunkte</div><div className="text-2xl font-bold mt-1">{score}</div></div>
            <div className="rounded-2xl p-4 bg-white dark:bg-gray-800 dark:text-gray-100 shadow"><div className="text-xs text-gray-500 dark:text-gray-400">Wiederholungs-Queue</div><div className="text-2xl font-bold mt-1">{reviewCount}</div></div>
          </div>
        </div>
      );
    }

    function QuestionCard({ q, idx, submitted, onSubmit, onNext, getTier }){
      const [selectedDisplay, setSelectedDisplay] = useState([]);
      const displayOrder = useMemo(()=> getDisplayOrder(q.id, idx), [q.id, idx]);
      useEffect(()=>{ setSelectedDisplay([]); }, [q.id, idx]);
      const toggle = (dispIdx) => setSelectedDisplay(prev => prev.includes(dispIdx)? prev.filter(x=>x!==dispIdx):[...prev, dispIdx]);
      const correctSet = new Set(q.correct);
      const group = GROUPS.find(g=>q.tags.some(t=>g.tags.includes(t))) || GROUPS[GROUPS.length-1];
      const tierValue = getTier(q.id);
      return (
        <div className="bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-0 overflow-hidden">
          <div className={`h-2 w-full bg-gradient-to-r ${group.color.grad}`} />
          <div className="p-6">
            <div className="mb-3 text-xs text-gray-500 dark:text-gray-400 flex flex-wrap items-center gap-2">
              {q.tags.map(t => (<Chip key={t} className={`${group.color.bg} ${group.color.border} ${group.color.text}`}>{t}</Chip>))}
              <Chip>Schwierigkeit {q.difficulty}</Chip>
              <Chip>Stand {q.last_checked}</Chip>
              <Chip>Tier {tierValue}</Chip>
            </div>
            <h2 className="text-lg font-semibold mb-4">{q.question}</h2>
            <div className="grid gap-2">
              {displayOrder.map((origIdx, dispIdx) => {
                const isChosen = selectedDisplay.includes(dispIdx);
                const isCorrect = correctSet.has(origIdx);
                const show = submitted;
                let classes = "text-left px-4 py-3 rounded-xl border transition flex items-start gap-3 dark:border-gray-700";
                if (show) {
                  if (isCorrect) {
                    classes += " border-green-600 bg-green-50 dark:border-green-400 dark:bg-green-900/40";
                  } else if (isChosen) {
                    classes += " border-red-600 bg-red-50 dark:border-red-400 dark:bg-red-900/40";
                  } else {
                    classes += " bg-white dark:bg-gray-800";
                  }
                } else {
                  classes += " bg-white hover:bg-gray-50 dark:bg-gray-800 dark:hover:bg-gray-700";
                }
                return (
                  <label key={dispIdx} className={classes}>
                    <input type="checkbox" className="mt-1" disabled={submitted} checked={isChosen} onChange={()=>toggle(dispIdx)} />
                    <span><span className="font-medium mr-2">{String.fromCharCode(65+dispIdx)}.</span>{q.choices[origIdx]}</span>
                  </label>
                );
              })}
            </div>
            {!submitted ? (
              <div className="mt-4 flex gap-2">
                <button className="px-3 py-2 rounded-lg border dark:border-gray-600" onClick={() => onSubmit(selectedDisplay)}>Antwort abgeben</button>
                <button className="px-3 py-2 rounded-lg border dark:border-gray-600" onClick={onNext}>Überspringen</button>
              </div>
            ) : (
              <div className="mt-4 p-4 border rounded-xl bg-gray-50 dark:bg-gray-900 dark:border-gray-700">
                <div className="text-sm">
                  <div className="font-semibold mb-1">Auflösung & Erläuterung</div>
                  <p className="mb-2">{q.explain}</p>
                  <div className="text-xs text-gray-600 dark:text-gray-300">Rechtsgrundlage: {q.law_ref}</div>
                </div>
                <div className="mt-3 flex gap-2">
                  <button className="px-3 py-2 rounded-lg border" onClick={onNext}>Weiter</button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function UserAuthPanel({ users, setUsers, onLogin, theme, setTheme, userMeta }){
      const [mode, setMode] = useState("login");
      const [username, setUsername] = useState("");
      const [password, setPassword] = useState("");
      const [adminCode, setAdminCode] = useState("");
      const [error, setError] = useState("");
      const [info, setInfo] = useState("");

      const { isLoading: usersLoading, syncError: usersSyncError, isUsingFirestore: usersUsingFirestore } = userMeta || {};

      const adminExists = useMemo(() => users.some(u => u.role === "admin"), [users]);

      const upsertUserInFirestore = useCallback((user) => {
        const firebaseBridge = getFirebaseBridge();
        const normalized = normalizeUserForStorage(user);
        if(!firebaseBridge || !normalized) return;
        const { ensureApp, getFirestore, doc, setDoc, ensureAuthUser } = firebaseBridge;
        if(typeof ensureApp !== "function" || typeof getFirestore !== "function" || typeof doc !== "function" || typeof setDoc !== "function") return;
        (async () => {
          try{
            if(typeof ensureAuthUser === "function"){ await ensureAuthUser(); }
            const app = ensureApp();
            const db = getFirestore(app);
            const ref = doc(db, FIRESTORE_USERS_COLLECTION, normalized.id);
            await setDoc(ref, normalized, { merge: true });
          }catch(error){
            console.error('[Firestore] Nutzer konnte nicht geschrieben werden', error);
          }
        })();
      }, []);

      const handleLogin = (e) => {
        e.preventDefault();
        setError("");
        const trimmed = username.trim();
        if(!trimmed){ setError("Bitte Nutzername eingeben."); return; }
        const user = users.find(u => u.username.toLowerCase() === trimmed.toLowerCase());
        if(!user){ setError("Nutzer nicht gefunden."); return; }
        if(!passwordsMatch(user.passwordHash, password)){
          setError("Passwort stimmt nicht.");
          return;
        }
        onLogin(user.id);
        upsertUserInFirestore(user);
        setUsername("");
        setPassword("");
        setAdminCode("");
      };

      const handleRegister = (e) => {
        e.preventDefault();
        setError("");
        const trimmed = username.trim();
        if(!trimmed){ setError("Bitte Nutzername angeben."); return; }
        if(password.length < 4){ setError("Passwort muss mindestens 4 Zeichen haben."); return; }
        if(users.some(u => u.username.toLowerCase() === trimmed.toLowerCase())){
          setError("Nutzername bereits vergeben.");
          return;
        }
        let role = "user";
        const code = adminCode.trim();
        if(!adminExists && code && code.toUpperCase() === ADMIN_SECRET){
          role = "admin";
        }
        const newUser = { id: generateId("user"), username: trimmed, passwordHash: hashPassword(password), role };
        setUsers(prev => [...prev, newUser]);
        setInfo(role === "admin" ? "Neuer Admin angelegt." : "Neuer Nutzer angelegt.");
        onLogin(newUser.id);
        upsertUserInFirestore(newUser);
        setUsername("");
        setPassword("");
        setAdminCode("");
      };

      const submit = mode === "login" ? handleLogin : handleRegister;

      return (
        <div className="min-h-screen flex items-center justify-center p-6">
          <div className="max-w-md w-full bg-white dark:bg-gray-800 rounded-2xl shadow p-6">
            <div className="flex justify-between items-center mb-4">
              <h1 className="text-xl font-semibold">Lerntool E1 / E2a</h1>
              <button onClick={()=>setTheme(theme==='dark'?'light':'dark')} className="px-3 py-1 rounded-full border dark:border-gray-600 text-sm">
                {theme==='dark' ? '☀️ Light' : '🌙 Dark'}
              </button>
            </div>
            <div className="flex gap-2 mb-4">
              <button onClick={()=>setMode("login") } className={`flex-1 px-3 py-2 rounded-lg border ${mode==='login'? 'bg-blue-600 text-white border-blue-600':'dark:border-gray-600'}`}>Login</button>
              <button onClick={()=>setMode("register")} className={`flex-1 px-3 py-2 rounded-lg border ${mode==='register'? 'bg-blue-600 text-white border-blue-600':'dark:border-gray-600'}`}>Registrieren</button>
            </div>
            {usersSyncError ? (
              <div className="mb-3 text-sm text-red-600 dark:text-red-400">{usersSyncError}</div>
            ) : usersLoading ? (
              <div className="mb-3 text-sm text-blue-600 dark:text-blue-400">Synchronisiere Profile …</div>
            ) : usersUsingFirestore ? (
              <div className="mb-3 text-xs text-green-600 dark:text-green-400">Profile werden automatisch mit Firestore abgeglichen.</div>
            ) : null}
            <form onSubmit={submit} className="space-y-4">
              <div>
                <label className="text-sm font-medium block mb-1">Nutzername</label>
                <input value={username} onChange={e=>setUsername(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder="z.B. Max" />
              </div>
              <div>
                <label className="text-sm font-medium block mb-1">Passwort</label>
                <input type="password" value={password} onChange={e=>setPassword(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder="mind. 4 Zeichen" />
              </div>
              {mode==='register' && !adminExists && (
                <div>
                  <label className="text-sm font-medium block mb-1">Admin-Code (optional)</label>
                  <input value={adminCode} onChange={e=>setAdminCode(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder="POLIZEI-ADMIN" />
                  <p className="text-xs text-gray-500 mt-1">Nur mit gültigem Code wird ein Admin-Profil angelegt.</p>
                </div>
              )}
              {mode==='register' && adminExists && (
                <div className="text-xs text-gray-500 dark:text-gray-400">Admin-Profile können nur vom bestehenden Admin verwaltet werden.</div>
              )}
              {error && <div className="text-sm text-red-600 dark:text-red-400">{error}</div>}
              {info && !error && <div className="text-xs text-gray-500 dark:text-gray-400">{info}</div>}
              <button type="submit" className="w-full px-3 py-2 rounded-lg bg-blue-600 text-white">{mode==='login' ? 'Anmelden' : 'Profil anlegen'}</button>
            </form>
            {users.length > 0 && (
              <div className="mt-6">
                <div className="text-xs text-gray-500 dark:text-gray-400 uppercase tracking-wide">Vorhandene Profile</div>
                <div className="flex flex-wrap gap-2 mt-2">
                  {users.map(u => (
                    <span key={u.id} className="px-2 py-1 rounded-full border text-xs dark:border-gray-600">
                      {u.username}{u.role==='admin' ? ' · Admin' : ''}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function UserSwitcher({ users, activeUser, onLogout, onSwitch }){
      const canSwitchProfiles = activeUser.role === 'admin';
      const others = canSwitchProfiles ? users.filter(u => u.id !== activeUser.id) : [];
      return (
        <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
          <div>
            <div className="text-xs text-gray-500 dark:text-gray-400 uppercase tracking-wide">Angemeldet als</div>
            <div className="text-lg font-semibold">
              {activeUser.username}
              {activeUser.role === 'admin' ? <span className="ml-2 text-sm px-2 py-1 rounded-full bg-green-100 text-green-800 dark:bg-green-900/40 dark:text-green-200">Admin</span> : null}
            </div>
          </div>
          <div className="flex flex-wrap gap-2">
            {canSwitchProfiles && others.map(u => (
              <button key={u.id} onClick={()=>onSwitch(u.id)} className="px-3 py-1 rounded-full border dark:border-gray-600 text-sm">
                Wechsel zu {u.username}{u.role==='admin' ? ' ⭐' : ''}
              </button>
            ))}
            <button onClick={onLogout} className="px-3 py-1 rounded-full border dark:border-gray-600 text-sm">Abmelden</button>
          </div>
        </div>
      );
    }

    function PasswordChangeForm({ activeUser, onUpdatePassword }){
      const [current, setCurrent] = useState("");
      const [next, setNext] = useState("");
      const [confirm, setConfirm] = useState("");
      const [message, setMessage] = useState("");
      const [error, setError] = useState("");
      const [isOpen, setIsOpen] = useState(false);

      const resetForm = () => {
        setCurrent("");
        setNext("");
        setConfirm("");
      };

      useEffect(() => {
        if(!message) return;
        const t = setTimeout(() => setMessage(""), 4000);
        return () => clearTimeout(t);
      }, [message]);

      useEffect(() => {
        if(!error) return;
        const t = setTimeout(() => setError(""), 4000);
        return () => clearTimeout(t);
      }, [error]);

      useEffect(() => {
        if(!isOpen){
          resetForm();
          setError("");
          setMessage("");
        }
      }, [isOpen]);

      const handleSubmit = (e) => {
        e.preventDefault();
        setError("");
        setMessage("");

        if(!passwordsMatch(activeUser.passwordHash, current)){
          setError("Aktuelles Passwort ist falsch.");
          return;
        }
        if(next.length < 4){
          setError("Neues Passwort muss mindestens 4 Zeichen haben.");
          return;
        }
        if(next !== confirm){
          setError("Bestätigung stimmt nicht mit dem neuen Passwort überein.");
          return;
        }

        onUpdatePassword(next);
        setMessage("Passwort erfolgreich aktualisiert.");
        resetForm();
      };

      return (
        <div className="w-full bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6 mb-6">
          <div className="flex flex-wrap items-start justify-between gap-4">
            <div>
              <h2 className="text-lg font-semibold">Passwort</h2>
              <p className="text-sm text-gray-500 dark:text-gray-400">Ändern Sie Ihr Passwort regelmäßig, um Ihr Profil zu schützen.</p>
            </div>
            <button
              onClick={() => setIsOpen(open => !open)}
              className="px-3 py-2 rounded-lg border border-blue-600 text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-900/20"
            >
              {isOpen ? 'Abbrechen' : 'Passwort ändern'}
            </button>
          </div>

          {isOpen && (
            <form onSubmit={handleSubmit} className="mt-6 space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1">Aktuelles Passwort</label>
                <input type="password" value={current} onChange={e=>setCurrent(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" required />
              </div>
              <div className="grid gap-4 md:grid-cols-2">
                <div>
                  <label className="block text-sm font-medium mb-1">Neues Passwort</label>
                  <input type="password" value={next} onChange={e=>setNext(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" required />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1">Neues Passwort bestätigen</label>
                  <input type="password" value={confirm} onChange={e=>setConfirm(e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" required />
                </div>
              </div>
              {error && <div className="text-sm text-red-600 dark:text-red-400">{error}</div>}
              {message && !error && <div className="text-sm text-green-600 dark:text-green-400">{message}</div>}
              <div className="flex justify-end gap-2">
                <button type="button" onClick={() => setIsOpen(false)} className="px-3 py-2 rounded-lg border dark:border-gray-600">
                  Schließen
                </button>
                <button type="submit" className="px-3 py-2 rounded-lg bg-blue-600 text-white">
                  Passwort speichern
                </button>
              </div>
            </form>
          )}
        </div>
      );
    }

    function QuestionForm({ draft, onChange, onSubmit, onCancel, submitLabel, disableId }){
      if(!draft) return null;
      const updateField = (field, value) => onChange({ ...draft, [field]: value });
      const updateChoice = (index, value) => {
        const choices = draft.choices.map((c,i)=> i===index ? value : c);
        onChange({ ...draft, choices });
      };
      const toggleCorrect = (index) => {
        const has = draft.correct.includes(index);
        const correct = has ? draft.correct.filter(i=>i!==index) : [...draft.correct, index];
        onChange({ ...draft, correct });
      };
      return (
        <form onSubmit={(e)=>{e.preventDefault(); onSubmit();}} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">Frage-ID</label>
            <input value={draft.id} onChange={e=>updateField('id', e.target.value)} disabled={disableId} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder="z.B. bdg-101" />
            <p className="text-xs text-gray-500 mt-1">{disableId ? 'Bestehende IDs können hier nicht geändert werden.' : 'Leer lassen, um automatisch eine ID zu erzeugen.'}</p>
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Fragetext</label>
            <textarea value={draft.question} onChange={e=>updateField('question', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" rows={4} placeholder="Frage eingeben" />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">Antwortoptionen (markieren Sie die richtigen Antworten)</label>
            <div className="space-y-2">
              {draft.choices.map((choice,index)=>(
                <div key={index} className="flex items-center gap-2">
                  <input type="checkbox" checked={draft.correct.includes(index)} onChange={()=>toggleCorrect(index)} />
                  <input value={choice} onChange={e=>updateChoice(index, e.target.value)} className="flex-1 px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder={`Antwort ${index+1}`} />
                </div>
              ))}
            </div>
          </div>
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1">Tags</label>
              <input value={draft.tags.join(', ')} onChange={e=>updateField('tags', e.target.value.split(',').map(t=>t.trim()).filter(Boolean))} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder="BDG, SPG" />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Rechtsgrundlage</label>
              <input value={draft.law_ref} onChange={e=>updateField('law_ref', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" placeholder="z.B. BDG § 43" />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Schwierigkeit</label>
              <select value={draft.difficulty} onChange={e=>updateField('difficulty', Number(e.target.value))} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900">
                {[1,2,3,4,5].map(n => <option key={n} value={n}>Level {n}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Stand</label>
              <input type="date" value={draft.last_checked || ""} onChange={e=>updateField('last_checked', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" />
            </div>
          </div>
          <div>
            <label className="block text-sm font-medium mb-1">Erläuterung</label>
            <textarea value={draft.explain} onChange={e=>updateField('explain', e.target.value)} className="w-full px-3 py-2 rounded-lg border dark:border-gray-600 dark:bg-gray-900" rows={3} placeholder="Hinweise und Begründung" />
          </div>
          <div className="flex justify-end gap-2">
            <button type="button" onClick={onCancel} className="px-3 py-2 rounded-lg border dark:border-gray-600">Abbrechen</button>
            <button type="submit" className="px-3 py-2 rounded-lg bg-blue-600 text-white">{submitLabel}</button>
          </div>
        </form>
      );
    }

    function AdminPanel({ questions, setQuestions, questionMeta }){
      const [mode, setMode] = useState("list");
      const [draft, setDraft] = useState(null);
      const [message, setMessage] = useState("");
      const [error, setError] = useState("");

      const {
        isUsingFirestore = false,
        isLoading: isSyncLoading = false,
        syncError = null,
        firestoreConfigured = false,
        firebaseConfigValid = false,
      } = questionMeta || {};

      useEffect(() => {
        if(message){
          const t = setTimeout(() => setMessage(""), 4000);
          return () => clearTimeout(t);
        }
      }, [message]);

      const statusBadges = [];
      if(isUsingFirestore){
        statusBadges.push({
          key: 'firestore-active',
          text: 'Firestore verbunden',
          className: 'bg-emerald-100 text-emerald-800 dark:bg-emerald-900/60 dark:text-emerald-200'
        });
      } else if(firebaseConfigValid){
        statusBadges.push({
          key: 'firestore-loading',
          text: isSyncLoading ? 'Verbindung zu Firestore wird aufgebaut…' : 'Firestore-Konfiguration erkannt',
          className: 'bg-blue-100 text-blue-800 dark:bg-blue-900/60 dark:text-blue-200'
        });
      } else {
        statusBadges.push({
          key: 'local-storage',
          text: 'Lokale Speicherung aktiv',
          className: 'bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-200'
        });
      }
      if(!firebaseConfigValid && firestoreConfigured){
        statusBadges.push({
          key: 'config-incomplete',
          text: 'Firebase-Konfiguration vervollständigen.',
          className: 'bg-amber-100 text-amber-800 dark:bg-amber-900/60 dark:text-amber-200'
        });
      }
      if(!firestoreConfigured){
        statusBadges.push({
          key: 'config-missing',
          text: 'Firebase-Initialisierung im HTML ergänzen, um Firestore zu aktivieren.',
          className: 'bg-amber-100 text-amber-800 dark:bg-amber-900/60 dark:text-amber-200'
        });
      }
      if(syncError){
        statusBadges.push({
          key: 'sync-error',
          text: syncError,
          className: 'bg-red-100 text-red-800 dark:bg-red-900/60 dark:text-red-200'
        });
      }

      const startEdit = (q) => {
        setDraft({ ...q, choices:[...q.choices], correct:[...q.correct], tags:[...q.tags] });
        setMode("edit");
        setError("");
      };

      const startCreate = () => {
        setDraft({ id:"", question:"", choices:["","","","",""], correct:[], explain:"", law_ref:"", tags:[], last_checked:new Date().toISOString().slice(0,10), difficulty:1 });
        setMode("create");
        setError("");
      };

      const seedDefaultQuestions = () => {
        if(!DEFAULT_QUESTIONS.length) return;
        const confirmed = window.confirm('Standardfragen übernehmen? Dadurch werden bestehende Fragen überschrieben.');
        if(!confirmed) return;
        setQuestions(DEFAULT_QUESTIONS);
        setMessage(`${DEFAULT_QUESTIONS.length} Standardfragen übernommen.`);
        setError("");
      };

      const cancel = () => {
        setMode("list");
        setDraft(null);
      };

      const validate = (data) => {
        if(!data.question || !data.question.trim()) return "Fragetext darf nicht leer sein.";
        if(!data.choices.every(c => c && c.trim())) return "Alle Antwortoptionen müssen ausgefüllt sein.";
        if(!data.correct.length) return "Mindestens eine Antwort muss als richtig markiert sein.";
        return "";
      };

      const handleSubmit = () => {
        if(!draft) return;
        const normalized = {
          ...draft,
          id: draft.id.trim(),
          question: draft.question.trim(),
          choices: draft.choices.map(c => c.trim()),
          correct: [...draft.correct].sort((a,b)=>a-b),
          tags: draft.tags.map(t=>t.trim()).filter(Boolean),
          law_ref: (draft.law_ref || "").trim(),
          explain: (draft.explain || "").trim(),
          last_checked: draft.last_checked || new Date().toISOString().slice(0,10),
          difficulty: Number(draft.difficulty) || 1,
        };
        const validationError = validate(normalized);
        if(validationError){ setError(validationError); return; }
        if(mode === "edit"){
          setQuestions(prev => prev.map(q => q.id === normalized.id ? normalized : q));
          setMessage(`Frage ${normalized.id} aktualisiert.`);
        } else {
          let newId = normalized.id;
          if(!newId){
            const base = normalized.tags[0] ? normalized.tags[0].toLowerCase() : 'frage';
            newId = generateId(base);
          }
          if(questions.some(q => q.id === newId)){
            setError("Diese ID ist bereits vergeben.");
            return;
          }
          setQuestions(prev => [...prev, { ...normalized, id: newId }]);
          setMessage(`Neue Frage ${newId} hinzugefügt.`);
        }
        setMode("list");
        setDraft(null);
        setError("");
      };

      const sortedQuestions = [...questions].sort((a,b) => a.id.localeCompare(b.id));

      return (
        <div className="bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6 space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold">Adminbereich: Fragen verwalten</h2>
            {mode === 'list' && (
              <button onClick={startCreate} className="px-3 py-2 rounded-lg bg-green-600 text-white">Neue Frage</button>
            )}
          </div>
          {statusBadges.length > 0 && (
            <div className="flex flex-wrap gap-2 text-xs">
              {statusBadges.map(badge => (
                <span key={badge.key} className={`px-2 py-1 rounded-full ${badge.className}`}>{badge.text}</span>
              ))}
            </div>
          )}
          {firebaseConfigValid && !questions.length && (
            <div className="p-4 border border-dashed border-blue-300 dark:border-blue-500 rounded-xl text-sm space-y-2">
              <p>Deine Firestore-Sammlung enthält noch keine Fragen. Du kannst die Standardfragen übernehmen oder per Import eigene Fragen hochladen.</p>
              <div className="flex flex-wrap items-center gap-3">
                <button onClick={seedDefaultQuestions} className="px-3 py-2 rounded-lg bg-blue-600 text-white">Standardfragen laden</button>
                <span className="text-xs text-gray-600 dark:text-gray-300">Alternativ: JSON importieren oder eine neue Frage erstellen.</span>
              </div>
            </div>
          )}
          {message && <div className="text-sm text-green-600 dark:text-green-300">{message}</div>}
          {error && <div className="text-sm text-red-600 dark:text-red-400">{error}</div>}
          {mode === "list" ? (
            <div className="space-y-2 max-h-96 overflow-y-auto pr-2">
              {sortedQuestions.map(q => (
                <div key={q.id} className="p-3 border rounded-xl dark:border-gray-700 flex items-start justify-between gap-4">
                  <div>
                    <div className="text-sm font-semibold">{q.id}</div>
                    <div className="text-sm text-gray-600 dark:text-gray-300">{q.question}</div>
                    <div className="mt-1 text-xs text-gray-500 dark:text-gray-400">Tags: {q.tags.join(', ')} · Stand: {q.last_checked}</div>
                  </div>
                  <button onClick={()=>startEdit(q)} className="px-3 py-2 rounded-lg border dark:border-gray-600">Bearbeiten</button>
                </div>
              ))}
              {!sortedQuestions.length && <div className="text-sm text-gray-500">Keine Fragen vorhanden.</div>}
            </div>
          ) : (
            <QuestionForm draft={draft} onChange={setDraft} onSubmit={handleSubmit} onCancel={cancel} submitLabel={mode==='edit' ? 'Speichern' : 'Erstellen'} disableId={mode==='edit'} />
          )}
        </div>
      );
    }

    function UserApp({ activeUser, users, setUsers, setActiveUserId, theme, setTheme, questions, setQuestions, questionMeta, userMeta }){
      const userId = activeUser.id;
      const viewState = useUserLocalStorage(userId, "view", "dashboard");
      const [view, setView] = viewState;
      const progressMeta = viewState?.meta || {};
      const [mode, setMode] = useUserLocalStorage(userId, "mode", "training");
      const [filter, setFilter] = useUserLocalStorage(userId, "filter", DEFAULT_FILTER);
      const [review, setReview] = useUserLocalStorage(userId, "review", []);
      const [metrics, setMetrics] = useUserLocalStorage(userId, "metrics", DEFAULT_METRICS);
      const [score, setScore] = useUserLocalStorage(userId, "score", 0);
      const [streak, setStreak] = useUserLocalStorage(userId, "streak", 0);
      const [idx, setIdx] = useUserLocalStorage(userId, "idx", 0);
      const [tierMap, setTierMap] = useUserLocalStorage(userId, "tiers", {});
      const [seed, setSeed] = useState(0);
      const [showExplain, setShowExplain] = useState(false);
      const [lockedQuestion, setLockedQuestion] = useState(null);
      const [lockedIdx, setLockedIdx] = useState(null);

      const { syncError: userSyncError, isLoading: usersLoading, isUsingFirestore: usersUsingFirestore } = userMeta || {};

      useEffect(()=>{ setShowExplain(false); }, [idx, userId]);

      useEffect(()=>{
        if(view === 'admin' && activeUser.role !== 'admin'){
          setView('dashboard');
        }
      }, [view, activeUser.role, setView]);

      const updatePassword = useCallback((newPassword) => {
        setUsers(prev => prev.map(u => u.id === activeUser.id ? { ...u, passwordHash: hashPassword(newPassword) } : u));
      }, [activeUser.id, setUsers]);

      const safeFilterRaw = (filter && typeof filter === 'object') ? filter : cloneValue(DEFAULT_FILTER);
      const filterTags = Array.isArray(safeFilterRaw.tags) ? safeFilterRaw.tags : [];
      const filterDifficulty = Number(safeFilterRaw.difficulty) || 0;
      const safeFilter = { tags: filterTags, difficulty: filterDifficulty };
      const safeMetrics = (metrics && typeof metrics === 'object') ? metrics : cloneValue(DEFAULT_METRICS);
      const safeReview = Array.isArray(review) ? review : [];

      const getTier = useCallback((id) => {
        const map = (tierMap && typeof tierMap === 'object') ? tierMap : {};
        const value = map[id];
        const tier = typeof value === 'number' ? value : 2;
        return Math.max(1, Math.min(5, tier));
      }, [tierMap]);

      const adjustTier = useCallback((id, delta) => {
        setTierMap(prev => {
          const base = (prev && typeof prev === 'object') ? { ...prev } : {};
          const current = typeof base[id] === 'number' ? base[id] : 2;
          const next = Math.max(1, Math.min(5, current + delta));
          base[id] = next;
          return base;
        });
      }, [setTierMap]);

      const orderSeed = useMemo(() => `${userId || "anon"}#${seed}`, [userId, seed]);

      const pool = useMemo(() => {
        let p = Array.isArray(questions) ? questions : [];
        if (safeFilter.tags.length) p = p.filter(q => q.tags.some(t => safeFilter.tags.includes(t)));
        if (safeFilter.difficulty) p = p.filter(q => q.difficulty === safeFilter.difficulty);
        if (mode === "mission"){
          const firstTag = safeFilter.tags?.[0] || "BDG";
          p = p.filter(q => q.tags.includes(firstTag));
        }
        return weightedOrder(p, getTier, orderSeed);
      }, [questions, safeFilter, mode, orderSeed, getTier]);

      const current = pool.length ? pool[idx % pool.length] : null;
      const lockedQuestionId = lockedQuestion ? lockedQuestion.id : null;

      useEffect(() => {
        if(!showExplain){
          setLockedQuestion(null);
          setLockedIdx(null);
        }
      }, [showExplain]);

      useEffect(() => {
        if(!pool.length){
          setLockedQuestion(null);
          setLockedIdx(null);
          setShowExplain(false);
          return;
        }
        if(showExplain && lockedQuestionId){
          const exists = pool.some(q => q.id === lockedQuestionId);
          if(!exists){
            setLockedQuestion(null);
            setLockedIdx(null);
            setShowExplain(false);
          }
        }
      }, [pool, showExplain, lockedQuestionId]);

      const rank = rankFor(score || 0);
      const progress = pool.length ? ((idx % pool.length) / pool.length) * 100 : 0;

      const stats = useMemo(()=>{
        const result={};
        for(const g of GROUPS){ result[g.key]={ total:0, attempted:0, correct:0, color:g.color, title:g.title }; }
        for(const q of Array.isArray(questions)?questions:[]){
          const group = GROUPS.find(g=>q.tags.some(t=>g.tags.includes(t))) || GROUPS[GROUPS.length-1];
          const key = group.key;
          result[key].total++;
          const attempts = safeMetrics.attemptedIds?.[q.id] || 0;
          const correct = safeMetrics.correctIds?.[q.id] || 0;
          result[key].attempted += attempts;
          result[key].correct += correct;
        }
        return result;
      }, [questions, safeMetrics]);

      const submitAnswer = (selectedDisplayIdx) => {
        if(!current || showExplain) return;
        const displayOrder = getDisplayOrder(current.id, idx);
        const toOriginal = (i) => displayOrder[i];
        const selectedOriginalIdx = selectedDisplayIdx.map(toOriginal);
        const correctSet = new Set(current.correct);
        const selectedSet = new Set(selectedOriginalIdx);
        const allOptions = current.choices.map((_,i)=>i);
        const isExact = allOptions.every(i=>correctSet.has(i)===selectedSet.has(i));
        setLockedQuestion(cloneValue(current));
        setLockedIdx(idx);
        setShowExplain(true);
        if(isExact){
          setScore(s=> (s || 0) + 10);
          setStreak(s=> (s || 0) + 1);
          setReview(prev => {
            const list = Array.isArray(prev) ? prev : [];
            return list.filter(id => id !== current.id);
          });
          adjustTier(current.id, +1);
        } else {
          setStreak(0);
          setReview(prev => {
            const list = Array.isArray(prev) ? prev : [];
            return list.includes(current.id) ? list : [...list, current.id];
          });
          adjustTier(current.id, -1);
        }
        setMetrics(m=>{
          const base = (m && typeof m === 'object') ? m : cloneValue(DEFAULT_METRICS);
          const attemptedIds = { ...(base.attemptedIds || {}) };
          const correctIds = { ...(base.correctIds || {}) };
          attemptedIds[current.id] = (attemptedIds[current.id] || 0) + 1;
          if(isExact){
            correctIds[current.id] = (correctIds[current.id] || 0) + 1;
          }
          return {
            totalAttempts: (base.totalAttempts || 0) + 1,
            totalCorrect: (base.totalCorrect || 0) + (isExact ? 1 : 0),
            attemptedIds,
            correctIds,
          };
        });
      };

      const next = () => {
        setLockedQuestion(null);
        setLockedIdx(null);
        setIdx(i => (i || 0) + 1);
        setShowExplain(false);
      };

      const toggleTag = (tag) => {
        setFilter(prev => {
          const base = (prev && typeof prev === 'object') ? prev : cloneValue(DEFAULT_FILTER);
          const currentTags = Array.isArray(base.tags) ? base.tags : [];
          const exists = currentTags.includes(tag);
          const tags = exists ? currentTags.filter(t=>t!==tag) : [...currentTags, tag];
          return { ...base, tags };
        });
      };

      const resetProgress = () => {
        if(!window.confirm('Fortschritt wirklich für dieses Profil löschen?')) return;
        ['view','mode','filter','review','metrics','score','streak','idx','tiers'].forEach(key => localStorage.removeItem(`${userId}:${key}`));
        setView('dashboard');
        setMode('training');
        setFilter(cloneValue(DEFAULT_FILTER));
        setReview([]);
        setMetrics(cloneValue(DEFAULT_METRICS));
        setScore(0);
        setStreak(0);
        setIdx(0);
        setTierMap({});
        setSeed(s=>s+1);
        setShowExplain(false);
      };

      const uniqueTags = Array.from(new Set(GROUPS.flatMap(g=>g.tags)));
      const activeQuestion = showExplain && lockedQuestion ? lockedQuestion : current;
      const activeIdx = showExplain && lockedIdx !== null ? lockedIdx : idx;

      const progressStatus = (() => {
        if(!userId) return null;
        if(progressMeta.syncError){
          return { tone: 'error', text: progressMeta.syncError };
        }
        if(progressMeta.isLoading){
          return { tone: 'info', text: 'Fortschritt wird mit Firestore verbunden …' };
        }
        if(progressMeta.isUsingFirestore){
          return null;
        }
        return { tone: 'warning', text: 'Fortschritt wird derzeit nur lokal gespeichert. Prüfe die Firestore-Regeln für "userProgress" oder die anonyme Anmeldung.' };
      })();

      return (
        <div className="max-w-5xl mx-auto p-6 space-y-6">
          {userSyncError ? (
            <div className="p-3 rounded-xl bg-red-100 text-red-800 dark:bg-red-900/40 dark:text-red-200">{userSyncError}</div>
          ) : usersLoading ? (
            <div className="p-3 rounded-xl bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-200">Profile werden mit Firestore synchronisiert …</div>
          ) : usersUsingFirestore ? (
            <div className="p-3 rounded-xl bg-emerald-100 text-emerald-800 dark:bg-emerald-900/40 dark:text-emerald-200">Profiländerungen werden automatisch zwischen Geräten synchronisiert.</div>
          ) : null}

          {progressStatus && (
            <div className={`p-3 rounded-xl border ${progressStatus.tone === 'error'
              ? 'bg-red-50 border-red-200 text-red-800 dark:bg-red-900/30 dark:border-red-700 dark:text-red-100'
              : progressStatus.tone === 'info'
              ? 'bg-blue-50 border-blue-200 text-blue-800 dark:bg-blue-900/30 dark:border-blue-700 dark:text-blue-100'
              : 'bg-amber-50 border-amber-200 text-amber-800 dark:bg-amber-900/30 dark:border-amber-700 dark:text-amber-100'}`}>
              {progressStatus.text}
            </div>
          )}

          <UserSwitcher users={users} activeUser={activeUser} onLogout={()=>setActiveUserId(null)} onSwitch={setActiveUserId} />

          <PasswordChangeForm activeUser={activeUser} onUpdatePassword={updatePassword} />

          <header className="mb-2">
            <div className="rounded-2xl p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow flex flex-wrap items-center gap-4 justify-between">
              <div>
                <h1 className="text-2xl font-bold">Lerntool E1 / E2a</h1>
                <p className="text-sm opacity-90">Prüfungsrealistisches MC-Training · 5 Optionen · Mehrfachauswahl · Antwortmischung · Spaced Repetition</p>
              </div>
              <div className="flex gap-2 items-center flex-wrap">
                <button onClick={()=>setView('dashboard')} className={`px-3 py-1 rounded-full border ${view==='dashboard'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Dashboard</button>
                <button onClick={()=>setView('train')} className={`px-3 py-1 rounded-full border ${view==='train'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Training</button>
                {activeUser.role === 'admin' && (
                  <button onClick={()=>setView('admin')} className={`px-3 py-1 rounded-full border ${view==='admin'? 'bg-white text-blue-700' : 'bg-transparent border-white text-white'}`}>Admin</button>
                )}
                <button onClick={()=>setTheme(theme==='dark'?'light':'dark')} className="px-3 py-1 rounded-full border bg-transparent border-white text-white hover:bg-white/10">
                  {theme==='dark' ? '☀️ Light' : '🌙 Dark'}
                </button>
              </div>
            </div>
          </header>

          {view==='dashboard' && (<Dashboard stats={stats} rank={rank} score={score} reviewCount={safeReview.length} />)}

          {view==='train' && (
            <>
              <div className="mb-4 grid lg:grid-cols-4 sm:grid-cols-2 grid-cols-1 gap-4">
                <StatCard title="Trefferquote" value={`${safeMetrics.totalAttempts? Math.round((safeMetrics.totalCorrect/safeMetrics.totalAttempts)*100):0}%`} sub={`Richtig ${safeMetrics.totalCorrect} · Falsch ${Math.max(0, safeMetrics.totalAttempts - safeMetrics.totalCorrect)}`} />
                <StatCard title="Beantwortet gesamt" value={safeMetrics.totalAttempts || 0} sub={`${Object.keys(safeMetrics.attemptedIds||{}).length} unterschiedliche Fragen`} />
                <StatCard title="Streak" value={`${streak} 🔥`} sub="in Folge richtig" />
                <StatCard title="Rang" value={rankFor(score || 0)} sub={`${score || 0} XP`} />
              </div>

              <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-4">
                <div className="p-4 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow">
                  <div className="text-xs text-gray-500 dark:text-gray-400">Modus</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {["training","exam","mission"].map(val => (
                      <button key={val} onClick={() => setMode(val)} className={`px-3 py-1 rounded-full border dark:border-gray-600 ${mode===val?"bg-blue-600 text-white":"bg-white dark:bg-gray-700 dark:text-gray-100"}`}>{val}</button>
                    ))}
                  </div>
                </div>
                <div className="p-4 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow">
                  <div className="text-xs text-gray-500 dark:text-gray-400">Filter</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {uniqueTags.map(t => (
                      <button key={t} onClick={() => toggleTag(t)} className={`px-3 py-1 rounded-full border dark:border-gray-600 ${ safeFilter.tags.includes(t)?"bg-blue-100 border-blue-400":"bg-white dark:bg-gray-700 dark:text-gray-100"}`}>{t}</button>
                    ))}
                  </div>
                </div>
                <div className="p-4 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow">
                  <div className="text-xs text-gray-500 dark:text-gray-400">Einstellungen</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    <button className="px-3 py-1 rounded-lg border dark:border-gray-600" onClick={resetProgress}>Fortschritt zurücksetzen</button>
                  </div>
                </div>
              </div>

              {activeQuestion ? (
                <QuestionCard q={activeQuestion} idx={activeIdx} submitted={showExplain} onSubmit={submitAnswer} onNext={next} getTier={getTier} />
              ) : (
                <div className="bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6">Keine Fragen im aktuellen Filter.</div>
              )}

              <div className="mt-8 bg-white dark:bg-gray-800 dark:text-gray-100 rounded-2xl shadow p-6">
                <h3 className="font-semibold mb-2">Fragen importieren/exportieren (JSON)</h3>
                <p className="text-sm text-gray-600 dark:text-gray-300 mb-3">Format: [{"{"}"id","question","choices":[5],"correct":[0,2,4],"explain":"...","law_ref":"...","tags":[...],"last_checked":"YYYY-MM-DD","difficulty":1{"}"}]</p>
                <div className="flex gap-2 flex-wrap">
                  <button className="px-3 py-2 rounded-lg border dark:border-gray-600" onClick={() => {
                    const blob = new Blob([JSON.stringify(questions, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = 'fragenbank-demo.json'; a.click(); URL.revokeObjectURL(url);
                  }}>Export</button>

                  <label className="px-3 py-2 rounded-lg border cursor-pointer dark:border-gray-600">Import
                    <input type="file" accept="application/json" className="hidden" onChange={async (e)=>{
                      const file=e.target.files?.[0]; if(!file) return; const text=await file.text();
                      try{
                        const data=JSON.parse(text);
                        const ok = Array.isArray(data) && data.every(q => q && typeof q.id==="string" && typeof q.question==="string" && Array.isArray(q.choices) && q.choices.length===5 && Array.isArray(q.correct) && q.correct.every(n=>Number.isInteger(n)&&n>=0&&n<5) && Array.isArray(q.tags));
                        if(!ok){ alert('Ungültiges Format.'); return; }
                        setQuestions(data);
                        alert(`Import erfolgreich: ${data.length} Fragen übernommen.`);
                      }catch{ alert('Ungültiges JSON'); }
                    }}/>
                  </label>
                </div>
              </div>
            </>
          )}

          {view==='admin' && activeUser.role === 'admin' && (
            <AdminPanel questions={questions} setQuestions={setQuestions} questionMeta={questionMeta} />
          )}
        </div>
      );
    }

    function App(){
      const {
        questions,
        setQuestions,
        isUsingFirestore,
        isLoading,
        syncError,
        firestoreConfigured,
        firebaseConfigValid,
      } = useQuestions();
      const usersHook = useUsers();
      const [users, setUsers] = usersHook;
      const usersMeta = usersHook.meta;
      const [activeUserId, setActiveUserId] = useLocalStorage("activeUserId", null);
      const [theme, setTheme] = useLocalStorage("theme","light");

      useEffect(()=>{
        if(theme === "dark"){ document.documentElement.classList.add("dark"); }
        else { document.documentElement.classList.remove("dark"); }
      },[theme]);

      const activeUser = users.find(u => u.id === activeUserId) || null;

      if(!activeUser){
        return <UserAuthPanel users={users} setUsers={setUsers} onLogin={setActiveUserId} theme={theme} setTheme={setTheme} userMeta={usersMeta} />;
      }

      const questionMeta = { isUsingFirestore, isLoading, syncError, firestoreConfigured, firebaseConfigValid };

      return <UserApp activeUser={activeUser} users={users} setUsers={setUsers} setActiveUserId={setActiveUserId} theme={theme} setTheme={setTheme} questions={questions} setQuestions={setQuestions} questionMeta={questionMeta} userMeta={usersMeta} />;
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
